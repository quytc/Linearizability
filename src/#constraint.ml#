let sprintf = Printf.sprintf
exception BreakLoop of int
let debug = false
let debugJOIN = false
let debugJOIN_Info = false
let debugPermute = false
let debugEXTEND = false

(* Global counter, for identification *)  
let maxID = ref (-1)

type ex = Q | Rest

let b = Buffer.create 20000 (* Buffer for the to_dot printing *)
let bp = Buffer.create 700 (* Buffer for the permutations. *)

type lockstate = Me | Others | Unlocked
let string_of_lockstate = function | Me -> "Me" | Others -> "Others" | Unlocked -> "Unlocked"
let char_of_lockstate = function | Me -> '*' | Others -> 'o' | Unlocked -> 'u'

(* ========================================================================== *)
type thread = {
    mutable pc: int;
		mutable interf_pc: int;
    mutable promise: Promise.t;
    mutable return: Data.t;
    (* mutable stack: Stack.t; *)
    bits: bool array;
    mutable trans: string array;

    mutable locks: lockstate array;

    mutable lbound: int;
    mutable range: int;
  }
      
let thread_create bits locks lbound = begin
  { pc=0;
	  interf_pc = 0;
    promise=Promise.NoPromise;
    return=Data.top;
    bits=(Array.make bits false);
    trans=[||];
    locks = (Array.make locks Unlocked);
    lbound=lbound; range=0;
  } 
end
let thread_clone th = {th with bits=Array.copy th.bits; locks=Array.copy th.locks;}
      
let thread_to_dot th buf = begin
  Buffer.add_string buf "PC: ";
  Buffer.add_string buf (string_of_int th.pc);
  Buffer.add_string buf "\tPromise: ";
  Promise.buffer buf th.promise;
  Buffer.add_string buf "\tReturn: ";
  Data.buffer buf th.return;
  Buffer.add_string buf "\tBits:[";
  Array.iter (fun bit -> Buffer.add_char buf (if bit then 'T' else 'F')) th.bits;
  Buffer.add_char buf ']';
  Buffer.add_string buf "\tLocks:[";
  Array.iter (fun lock -> Buffer.add_char buf (char_of_lockstate lock)) th.locks;
  Buffer.add_char buf ']';
end

let string_of_thread th = 
  sprintf "PC: %-2d | Promise: %-18s | Return: %c | Bits:[|%s] | Locks:[|%s]\tLower bound: %-2d -- Range: %d"
    th.pc (Promise.string_of th.promise) (Data.char_of th.return)
    (Array.fold_left (sprintf "%s%-5B|") "" th.bits) (Array.fold_left (fun acc lock -> sprintf "%s%-8s|" acc (string_of_lockstate lock)) "" th.locks)
    th.lbound th.range
    
let compare_thread th1 th2 =
  let cv1 = Pervasives.compare th1.pc th2.pc in
  if cv1 <> 0 then cv1 else
  let cv2 = Promise.compare th1.promise th2.promise in
  if cv2 <> 0 then cv2 else 
  let cv3 = Data.compare th1.return th2.return in
  if cv3 <> 0 then cv3 else 
  let cv4 = Pervasives.compare th1.bits th2.bits in
  if cv4 <> 0 then cv4 else 
  Pervasives.compare th1.locks th2.locks

(* ========================================================================== *)

type t = {
    
    mutable observer: Observer.state;      (** The state of the observer *)
    mutable nth:int;
    mutable threads: thread array;
    mutable heap: Info.t array array;
		mutable scope: int array array;
		mutable data: int array array;
    mutable bound: int;
    gvar: int;
    colors:int;
		mutable cutpoints: int;
    mutable vars: Label.t array;
    mutable translation: string array;
    
    mutable permutation: int array;
    mutable iterator: int array;
    mutable in_queue: bool;
    mutable in_slice: bool;
    id:int;
    example:ex;
    mutable join_count:int;
    mutable messages:string list;
    mutable parents: t list;

    mutable encoding: string;
  } 

let create ?(example=Rest) nth gvars gcolors bits locks = incr maxID;
  let gvar = 3 + Array.length gvars in (* 3 = null, bottom and free *)
  let colors = Array.length gcolors in
  let bound = gvar + colors - 1 in
  let bound' = bound+1 in
  let h = Array.make_matrix bound' bound' Info.none in
	let s = Array.make_matrix bound' 1 0 in
	let d = Array.make_matrix bound' 1 0 in
  for i=0 to bound do for j=0 to bound do h.(i).(j) <- (if i=j then Info.equal else Info.none); done; done;
  let threads = Array.init nth (fun _ -> thread_create bits locks (gvar + colors)) in
  {
  example=example;
  observer = Observer.init;
  nth = nth;
  threads = threads;
  heap = h;
	scope = s;
	data = d;
  gvar = gvar;
	cutpoints = 0;
  colors = colors;
  bound = bound;
	vars = [||];
  permutation=(Array.init nth (fun i -> i));
  iterator=(Array.init bound' (fun i -> i));

  translation = Array.append
    (Array.map Label.string_of (Array.append [|Label.nil;Label.bottom;Label.free(* ;Label.locked *)|] gvars))
    (Array.map Data.string_of gcolors);
  
  in_queue=false;
  in_slice=false;
  
  id = (!maxID);
  join_count = 0;
  messages = [];
  parents = [];

  encoding="";
}

let _clone t id =
  { t with id=id;
    threads = Array.map thread_clone t.threads;
(*     heap = Array.map (Array.map Info.clone) t.heap; *)
    heap = Array.map Array.copy t.heap;
		scope = Array.map Array.copy t.scope;
		data = Array.map Array.copy t.data;
    translation = Array.copy t.translation;
    permutation = Array.copy t.permutation;
    iterator = Array.copy t.iterator;
    (* will copy the rest *) 
  }

let clone t = incr maxID; _clone t (!maxID)

let string_of t = 
  sprintf "(%d)[Observer=%s]\n%s" t.id (Observer.string_of_state t.observer)
    (Array.fold_left (fun acc thi -> sprintf "%s\t%s\n" acc (string_of_thread t.threads.(thi))) "" t.permutation)

(* ========================================================================================================= *)
(* =====================                        Utilities                           ======================== *)
(* ========================================================================================================= *)
let is_q p = match p.example with Q -> true | _ -> false (* p.gvar > 4 *)

let id t = t.id
let observer t = t.observer
let set_observer t obs = t.observer <- obs
    
let nthreads p = p.nth
let gvar p = p.gvar
let var p = Array.length p.vars
let set_in_queue t v = t.in_queue <- v
let in_queue t = t.in_queue
let set_in_slice t v = t.in_slice <- v
let in_slice t = t.in_slice
    
let set_parent p p' = if !Globals.trace then p.parents <- [_clone p' p'.id]; ()

let log t message = if !Globals.trace then t.messages <- (Lazy.force message)::t.messages; ()
(*   let log t message = t.messages <- [message] *)

let pc p thi = p.threads.(thi).pc
let get_mark p i = p.data.(i).(0)
let bound p = p.bound
  let cutpoints p = p.cutpoints
(*
let check_cond p = begin
  if p.threads.(0).pc ==  20 && p.data.(6).(0) == 1 &&p.data.(7).(0) == 1&& Info.is_reach_more p.heap.(7).(4)== 0 && Info.is_reach_more p.heap.(6).(7)== 0
  then 0 else 1
    
  end*)
  
    (*let check_cond1 p = begin
  if p.bound >= 8 && p.threads.(0).pc == 1020 && p.data.(7).(0) == 0 && p.data.(6).(0) == 1 && Info.is_reach_one p.heap.(5).(6)== 0 && Info.is_reach_one p.heap.(6).(7)== 0 && 
       Info.is_reach_more p.heap.(7).(4)== 0 then 0 else 1*)

let interf_pc p thi = p.threads.(thi).interf_pc

let set_pc p thi pc = p.threads.(thi).pc <- pc  

let logical_pc p thi = p.threads.(p.permutation.(thi)).pc

let physical_thread p thi = p.permutation.(thi)

let promise p thi = p.threads.(thi).promise
let set_promise p thi prom = p.threads.(thi).promise <- prom
let reset_prom p thi = set_promise p thi Promise.NoPromise

let set_return p thi d = p.threads.(thi).return <- d

let is_uptodate bit thi p = p.threads.(thi).bits.(bit)
let set_bit (v:bool) (bit:int) (p:t) (thi:int) = p.threads.(thi).bits.(bit) <- v
let make_uptodate bit thi p = set_bit true bit p thi
let reset_bits (bit:int) (p:t) = for thi=0 to p.nth-1 do set_bit false bit p thi done

    
let rec iter_trace p f acc = begin
  f p;
  List.iter (fun papa -> if not(List.mem papa acc) (*logically*) then iter_trace papa f (p::acc);) p.parents;
(*   List.iter (fun papa -> if not(List.memq papa acc) (\*physically*\) then iter_trace papa f (p::acc);) p.parents; *)
end
    

exception Stop (* to break foldings and iterations *)
exception Found of string

let __t p i = if i < p.gvar + p.colors then p.translation.(i) else begin
  try
    for thi=0 to p.nth - 1 do
      let th = p.threads.(thi) in
      if i >= th.lbound && i < th.lbound + th.range then raise (Found (sprintf "%s.%d" th.trans.(i-th.lbound) thi));
    done;
    "unknown"
  with Found trans -> trans 
end


(* =================================================================================== *)
let index p thi v = begin (* thi is a physical index *)
  if Label.is_global v
  then Label.unpack v
  else begin
    let shift = Label.unpack v in
    let th = p.threads.(thi) in
    assert( shift <= th.range );
    th.lbound + shift
  end
end



exception NullPointerDereferencing of t * (string Lazy.t)
exception DoubleFree of t * (string Lazy.t)
exception Dangling of t * (string Lazy.t)
exception FreeDereferencing of t * (string Lazy.t)
exception Cycle of t * (string Lazy.t)
exception IgnoreConstraint
exception ClashWithInit of t

exception Compare of int

let strict_compare p1 p2 = begin
  assert( p1.nth = p2.nth );
  try
    let cv0 = Pervasives.compare p1.observer p2.observer in
    if cv0 <> 0 then raise (Compare cv0);
    let cv1 = Pervasives.compare p1.bound p2.bound in
    if cv1 <> 0 then raise (Compare cv1);
    for thi=0 to p1.nth-1 do
      let cv = compare_thread p1.threads.( p1.permutation.(thi) ) p2.threads.( p2.permutation.(thi) ) in
      if cv <> 0 then raise (Compare cv);
    done;
    let cv_gvar = Pervasives.compare p1.gvar p2.gvar in
    if cv_gvar <> 0 then raise (Compare cv_gvar);
    let cv_colors = Pervasives.compare p1.colors p2.colors in
    if cv_colors <> 0 then raise (Compare cv_colors);

    for i=0 to p1.bound do for j=0 to p1.bound do
      let cv = Info.compare p1.heap.(p1.iterator.(i)).(p1.iterator.(j)) p2.heap.(p2.iterator.(i)).(p2.iterator.(j)) in
      if cv <> 0 then raise (Compare cv);
    done; done;
    0
  with Compare i -> i
end



let inspect_gworld p1 p2 = 
     Pervasives.compare p1.gvar p2.gvar lor 
     Pervasives.compare p1.colors p2.colors lor 
    Pervasives.compare p1.bound p2.bound




let reachmore p x y = if List.length( Info.get_b_label p.heap.(x).(y)) > 0 && (*List.length( Info.get_b_label p.heap.(x+1).(y+1)) > 1 &&*) p.data.(x).(0) == 1 then 0 else 1

let print_cons p = begin
  	print_string "\n\n";
	print_string "PC: "; print_int p.threads.(0).pc; print_string "\n";
	print_string "=========================================================================================\n";
	print_string "         ";
	 for i=0 to p.gvar - 1 do 
	  print_string (p.translation.(i));
		print_string "         ";
	 done;
	for i=0 to (Array.length p.vars) - 1 do 
	  print_string (Label.string_of p.vars.(i)); print_string "         ";
	 done;	
	for i=0 to p.cutpoints - 1 do 
	  print_string "c";print_int i; print_string "        "
	  done;	
	print_string "\n";
	print_string "----------------------------------Scope--------------------------------------------------\n";
				print_string "         ";
		for r=0 to  p.bound do 
	  print_int p.scope.(r).(0);print_string "         ";
	 done;
	print_string "\n";
		print_string "----------------------------------Marked--------------------------------------------------\n";
				print_string "         ";
		for r=0 to  p.bound do 
	  print_int p.data.(r).(0);print_string "         ";
	 done;
	print_string "\n";
		print_string "-----------------------------Info--------------------------------------------------------\n";
		
	  for i = 0 to p.bound do
			if i < p.gvar then begin  print_string (p.translation.(i));print_string "        " end
			else
			if i < p.gvar + (Array.length p.vars) then begin print_string (Label.string_of p.vars.(i- p.gvar)); print_string "        " end
			else  begin print_string "c"; print_int (i- p.gvar - (Array.length p.vars)); print_string "        " end;
			
		for j=0 to p.bound do			  
			 Info.print_cell p.heap.(i).(j);
			 (*if Info.is_reach p.heap.(i).(j) == 0 && List.length(Info.get_b_label p.heap.(i).(j)) > 0 then*)
			if (Info.is_none p.heap.(i).(j) <> 0 && Info.is_equal p.heap.(i).(j) <> 0) || Info.ord p.heap.(i).(j) == 2 then
				print_string "      "
				else
				
			print_string "         "
		done;
		print_string "\n-----------------------------------------------------------------------------------------\n";
		done;						
end


let print_merge_cons p p1 p2 = begin
	print_string "\n\n";
	print_string "PC: "; print_int p.threads.(0).pc; print_string "\n";
	print_string "===================================MERGE==========================================\n";
	print_string "       ";
	 for i=0 to p1.gvar - 1 do 
	  print_string (p.translation.(i));
		print_string "      ";
	 done;
	for i=0 to (Array.length p1.vars) - 1 do 
	  print_string (Label.string_of p1.vars.(i)); print_string "      ";
	 done;
	
	for i=0 to p1.cutpoints - 1 do 
	  print_string "c";print_int i; print_string "      " 
	  done;
	
		for i=0 to (Array.length p2.vars) - 1 do 
	  print_string (Label.string_of p2.vars.(i)); print_string "      ";
	 done;
	
	for i=0 to p2.cutpoints - 1 do 
	  print_string "c";print_int i; print_string "      "
	  done;	
		
	print_string "\n";
	print_string "--------------------------------Scope----------------------------------------\n";
				print_string "       ";
		for r=0 to  p.bound do 
	  print_int p.scope.(r).(0);print_string "      ";
	 done;
	print_string "\n";
		print_string "------------------------------Info-------------------------------------------\n";
		
	  for i = 0 to p1.bound do
			if i < p1.gvar then begin  print_string (p1.translation.(i));print_string "      " end
			else
			if i < p1.gvar + (Array.length p1.vars) then begin print_string (Label.string_of p1.vars.(i- p1.gvar)); print_string "        " end
			else  begin print_string "c"; print_int (i- p1.gvar - (Array.length p1.vars)); print_string "      " end;
			
		for j=0 to p.bound do			  
			 Info.print_cell p.heap.(i).(j);
			print_string "      ";	 
		done;
				print_string "\n---------------------------------------------------------------------------\n";		
		done;
		 for i = p1.bound+1 to p.bound do
     if i <=  p1.bound + (Array.length p2.vars) then begin print_string (Label.string_of p1.vars.(i- p1.bound-1)); print_string "        " end
			else  begin print_string "c"; print_int (i- 1 -p2.bound-(Array.length p2.vars)); print_string "      " end;
	
	   	for j=0 to p.bound do			  
			   Info.print_cell p.heap.(i).(j);
			   print_string "      ";	 
		  done;
				print_string "\n---------------------------------------------------------------------------\n";		
		done;		
end

let cell_strengthen (p:t) x y = begin
  let ord = Info.ord p.heap.(x).(y) in
  let mark = p.data.(y).(0) in
	let b_label = Info.get_b_label p.heap.(x).(y) in
	let a_label = Info.get_a_label p.heap.(x).(y) in
	(*check if b_label is empty*)
    if List.length(b_label) == 0 && ord <> 3 && List.nth a_label 0 == 2 then
         p.heap.(x).(y) <- Info.update_ord_a_label p.heap.(x).(y) ord;
    (*strengthen for data*)
   if List.nth a_label 0 == 2 then
         p.heap.(x).(y) <- Info.update_data_a_label p.heap.(x).(y) mark;
end

let cell_expand (p:t) x y = begin
	let a_label = Info.get_a_label p.heap.(x).(y) in
	let b_label = Info.get_b_label p.heap.(x).(y) in
  if List.nth a_label 1 <> 3 then 
		begin
	  let ord = List.nth a_label 1 in
	  (*check if b_label is empty*)
    if List.length(b_label) == 0 && Info.ord  p.heap.(x).(y) == 3 then
		  p.heap.(x).(y) <- Info.update_ord p.heap.(x).(y) ord;
		end;
    (*if List.nth a_label 2 <> 0 then 
		begin*)
    let mark = List.nth a_label 2 in
	  (*check if b_label is empty*)
    if  p.data.(y).(0) < mark then 
		  p.data.(y).(0) <- List.nth a_label 2;
		(*end;*)
end

let cell_expand1 (p:t) x y = begin
	let a_label = Info.get_a_label p.heap.(x).(y) in
  if Info.is_reach p.heap.(x).(y) == 0 then
   let mark = List.nth a_label 2 in
		  p.data.(y).(0) <- mark;

end

let cell_expand_all p  = begin
	for i = 3 to p.bound do
		for j = 3 to p.bound do			
    cell_expand1 p i j;		
		done;
	done;
end

let ord_strengthen p = begin
	for i = 3 to p.bound do
		for j = 3 to p.bound do
			 if (Info.is_equal p.heap.(i).(j)) == 0 && i <> j then 
      begin
        if p.data.(i).(0) == 2 &&  p.data.(j).(0) <> 2 && p.scope.(i).(0) == 0  then p.data.(i).(0) <- p.data.(j).(0)
    else
             if p.data.(i).(0) <> 2 &&  p.data.(j).(0) == 2 && p.scope.(i).(0) == 0 then p.data.(j).(0) <- p.data.(i).(0);
        (*Update data of i to j*)
        if  p.data.(j).(0) >= 1 then p.data.(i).(0) <- p.data.(j).(0);
				for k=0 to p.bound do
				 (*Update ord to i by paths to j*)
         if (Info.is_none p.heap.(k).(i)) == 0 && Info.is_none p.heap.(k).(j) == 0 && k <> j && Info.ord p.heap.(k).(j) == 2 then
					p.heap.(k).(i) <- p.heap.(k).(j);
				 (*Update ord from i by paths from j*)
         if (Info.is_none p.heap.(i).(k)) == 0 && Info.is_none p.heap.(j).(k) == 0  && Info.ord p.heap.(j).(k) == 2 then	
					p.heap.(i).(k) <- p.heap.(j).(k);
       done;
			end;
    cell_strengthen p i j;
    cell_expand p i j;
			for t = 0 to p.bound do
				let cell1 = p.heap.(i).(j) in
				let cell2 = p.heap.(j).(t) in
				if i <> j && j <> t &&  Info.ord cell1 == Info.ord cell2 && (Info.ord cell1 == 2 || Info.ord cell1 == 1 ) then
					p.heap.(i).(t) <- Info.update_ord p.heap.(i).(t) (Info.ord cell1);
				if i <> j && j <> t &&  Info.ord cell1 == 0 && (Info.ord cell2 == 2 || Info.ord cell2 == 1) then
					p.heap.(i).(t) <- Info.update_ord p.heap.(i).(t) (Info.ord cell2);
				if i <> j && j <> t &&  Info.ord cell2 == 0 && (Info.ord cell1 == 2 || Info.ord cell1 == 1) then
					p.heap.(i).(t) <- Info.update_ord p.heap.(i).(t) (Info.ord cell1);
				done;
		done;
	done;
end


let normal_strengthen p = begin 
			ord_strengthen p;
	 for i=0 to p.bound do
		for j=0 to p.bound do
				p.heap.(i).(i) <- Info.equal;
		(*For each pair of equality matrixes*)	
    if (Info.is_equal p.heap.(i).(j)) == 0 && i <> j then 
      begin	
        
			 for k=0 to p.bound do
				 (*Update paths to i by paths to j*)
         if (Info.is_none p.heap.(k).(i)) == 0 && k <> j then
					p.heap.(k).(i) <- p.heap.(k).(j);
				 (*Update paths from i by paths from j*)
         if (Info.is_none p.heap.(i).(k)) == 0 && k <> j then	
					p.heap.(i).(k) <- p.heap.(j).(k);
       done;
							p.heap.(j).(i) <- Info.equal;
		end;	
	done;	
	done;
   
end		
let update_scope p = begin
	(*update scope of local variables in p to local*)
	for i = p.gvar to p.bound do
		if p.scope.(i).(0) <> 2 then p.scope.(i).(0) <- 1
	done;
  for i = 0 to p.gvar-1 do
		p.scope.(i).(0) <- 0
	done;
	(*local variables reached from global are updated to global*)
    for i = 0 to p.bound do
	  for j = 0 to p.bound do
       if (Info.is_reach p.heap.(i).(j) == 0 || Info.is_equal p.heap.(i).(j) == 0) && p.scope.(i).(0) == 0 then
				p.scope.(j).(0) <- 0     					
	  done;
       done;
 for i = 0 to p.bound do
	  for j = 0 to p.bound do
       if (Info.is_reach p.heap.(i).(j) == 0 || Info.is_equal p.heap.(i).(j) == 0) && p.scope.(i).(0) == 0 then
				p.scope.(j).(0) <- 0     					
	  done;
       done;
  	p
end
(*---------------------Strengthen-------------------------*)
let strengthen p = begin 
			ord_strengthen p;
	 for i=0 to p.bound do
		for j=0 to p.bound do
				p.heap.(i).(i) <- Info.equal;
		(*For each pair of equality matrixes*)	
    if (Info.is_equal p.heap.(i).(j)) == 0 && i <> j then 
      begin	
        
			 for k=0 to p.bound do
				 (*Update paths to i by paths to j*)
         if (Info.is_none p.heap.(k).(i)) == 0 && k <> j then
					p.heap.(k).(i) <- p.heap.(k).(j);
				 (*Update paths from i by paths from j*)
         if (Info.is_none p.heap.(i).(k)) == 0 && k <> j then	
					p.heap.(i).(k) <- p.heap.(j).(k);
       done;
							p.heap.(j).(i) <- Info.equal;
		end;	
	done;	
	done;      
end		

(* will update the matrix in place *)
let _add p i j phi = begin
  assert( i <> j );
end

let is_cutpoint p x = begin
	update_scope p;
  let ret = ref 1 in
  if p.scope.(x).(0) == 1 then
    ret := 1
  else begin
	let z = ref (p.bound + 1) in
	for i = 0 to p.bound do
   if Info.is_reach p.heap.(i).(x) == 0  && !z == (p.bound + 1)  then z := i
			else
     if Info.is_reach p.heap.(i).(x) == 0  && !z <> (p.bound + 1)  then if Info.is_equal p.heap.(i).(!z) <> 0 then ret := 0 
	done;
	
	for i = 0 to 2 do
		if p.heap.(x).(i) == Info.equal then ret := 1
	done;
	
    for i = p.gvar + (Array.length(p.vars)) to p.bound do
      if x < p.gvar + (Array.length(p.vars)) && p.heap.(x).(i) == Info.equal then ret := 1
    done;
  for i = 0 to p.gvar + (Array.length(p.vars)) -1 do
    if x >= p.gvar + (Array.length(p.vars)) && p.heap.(x).(i) == Info.equal then ret := 1
  done;
  end;
	!ret
end



  let _mergeover (p:t) x fro till = begin
  strengthen p;
  let is_merged = ref 0 in
	for k = 3 to p.bound do
		if k <> x && (k <= fro || k > till) then
		if Info.is_equal p.heap.(x).(k) == 0 then is_merged := 1
	done;
	    if !is_merged == 0 then begin
  for i=0 to p.bound do
		for j=0 to p.bound do
			if Info.is_reach p.heap.(i).(x) == 0  && Info.is_reach p.heap.(x).(j) == 0 then
             p.heap.(i).(j) <- Info.merge_cell p.heap.(i).(x) p.heap.(x).(j) p.heap.(i).(j);	
      if Info.is_equal p.heap.(i).(x) == 0 then p.heap.(i).(j) <- p.heap.(x).(j);
      if Info.is_equal p.heap.(x).(j) == 0 then p.heap.(i).(j) <- p.heap.(i).(x);       
	  done;
	done;		
	end
end
let is_cutpoint' p x fro till = begin
  	let ret = ref 1 in
  if p.scope.(x).(0) == 1 then
    ret := 1
  else begin
      (*let p = clone p1 in
  for k = fro + 1 to till do
    _mergeover p k fro till;
       done;
	*)
	(*
	let z = ref (p.bound + 1) in
	for i = 0 to p.bound do
    if Info.is_reach p.heap.(i).(x) == 0 && (i <= fro || i > till) && !z == (p.bound + 1)  then z := i
	   else
      if Info.is_reach p.heap.(i).(x) == 0 && (i <= fro || i > till) && !z <> (p.bound + 1)  then
        if Info.is_equal p.heap.(i).(!z) <> 0 || Info.is_equal p.heap.(!z).(i) <> 0 then ret := 0 
	done;*)
	
		let z = ref (p.bound + 1) in
	for i = 0 to p.bound do
    if Info.is_reach p.heap.(i).(x) == 0 && i <> x && p.scope.(i).(0) == 0 && !z == (p.bound + 1)  then z := i
	   else
      if Info.is_reach p.heap.(i).(x) == 0 && i <> x&& !z <> (p.bound + 1)  then
        if Info.is_equal p.heap.(i).(!z) <> 0 || Info.is_equal p.heap.(!z).(i) <> 0 then ret := 0 
	done;
	
  end;	
	!ret
end
  
let copy_variable p x y = begin
	for i = 0 to p.bound do
	   p.heap.(i).(y) <- p.heap.(i).(x);
		 p.heap.(y).(i) <- p.heap.(x).(i);
	done;
	p.heap.(y).(y) <- Info.equal;
	p.scope.(y).(0) <- p.scope.(x).(0);
	p.data.(y).(0) <- p.data.(x).(0);
end

let add_cutpoint p = begin
let newbound = p.bound + 1 in
let newheap = Array.make_matrix (newbound+1) (newbound+1) Info.none in
let newscope = Array.make_matrix (newbound+1) (1) 1 in	
let newsdata = Array.make_matrix (newbound+1) (1) 0 in	
   for i = 0 to p.bound do
		newscope.(i).(0) <- p.scope.(i).(0);
		newsdata.(i).(0) <-p.data.(i).(0);
		for j = 0 to p.bound do
	  newheap.(i).(j) <- p.heap.(i).(j);
	done;
	done;	
p.heap <- newheap;
p.scope <-newscope;
p.data <- newsdata;
p.bound <- newbound ;
p.cutpoints <- p.cutpoints + 1;	
end

let kill_cutpoints p x = begin
        let newbound = p.bound - 1 in
let newheap = Array.make_matrix (newbound+1) (newbound+1) Info.none in
let newscope = Array.make_matrix (newbound+1) (1) 1 in	
let newsdata = Array.make_matrix (newbound+1) (1) 0 in	
 for i = 0 to p.bound - p.cutpoints do
   newscope.(i).(0) <- p.scope.(i).(0);
   newsdata.(i).(0) <- p.data.(i).(0);
		for j = 0 to p.bound - p.cutpoints do
	  newheap.(i).(j) <- p.heap.(i).(j);
	  done;
	done;
  for i = 0 to p.bound  do
    if i < x  then begin newscope.(i).(0) <- p.scope.(i).(0); newsdata.(i).(0) <- p.data.(i).(0); end
		else
    if i > x then begin newscope.(i-1).(0) <- p.scope.(i).(0); newsdata.(i-1).(0) <- p.data.(i).(0); end;
		for j = 0 to p.bound do
			if i < x && j < x then
	       newheap.(i).(j) <- p.heap.(i).(j)
			else
			if i > x && j < x then
				 newheap.(i-1).(j) <- p.heap.(i).(j)
			else
     if i > x && j > x then
				 newheap.(i-1).(j-1) <- p.heap.(i).(j)
			else
			if i < x && j > x then
				 newheap.(i).(j-1) <- p.heap.(i).(j);
	  done;
	done;			
p.heap <- newheap;
p.scope <-newscope;
p.data <-newsdata;
p.bound <- newbound ;
  p.cutpoints <- p.cutpoints - 1;	
  
end

(*Kill the variable from matrix p*)
let _kill (p:t) x = begin 
  (*print_string "before kill \n"; print_cons p;*)

  strengthen p;
	
  let is_merged = ref 0 in
	for k = 3 to p.bound do
   if k <> x then 
		  if Info.is_equal p.heap.(x).(k) == 0 then is_merged := 1
  done;	

	if 	!is_merged == 0 && is_cutpoint p x == 0 then begin
		   (* print_string "---------------------------------------------------------------------------------------------------------------------------------------------------\n";
				print_int x;*)
			  add_cutpoint p;				
				copy_variable p x p.bound end	
	else		
	if !is_merged == 0 then 
		begin			
	for i=0 to p.bound do
		    for j=0 to p.bound do
		    	if Info.is_reach p.heap.(i).(x) == 0  && Info.is_reach p.heap.(x).(j) == 0 then
             p.heap.(i).(j) <- Info.merge_cell p.heap.(i).(x) p.heap.(x).(j) p.heap.(i).(j);	
						
          if Info.is_equal p.heap.(i).(x) == 0 then p.heap.(i).(j) <- p.heap.(x).(j);
          if Info.is_equal p.heap.(x).(j) == 0 then p.heap.(i).(j) <- p.heap.(i).(x);        
	      done;
	done;	
  end;
	for i=0 to p.bound do	
		p.heap.(x).(i) <- Info.none; 
		p.heap.(i).(x) <- Info.none; 		
	done;
	(*print_string "After kill \n"; print_cons p;*)
  p.heap.(x).(x) <- Info.equal;
    p.data.(x).(0) <- 0;
end

let _add_cutpoint   (p:t) fro till = begin
  let ret = ref 0 in
  for x = fro +1 to till do
    let is_merged = ref 0 in
	for k = 3 to p.bound do
		if k <> x && (k <= fro || k > till) then
		if Info.is_equal p.heap.(x).(k) == 0 then is_merged := 1
	done;
	(*if there is no variable that is same as x*)
    if !is_merged == 0 && is_cutpoint' p x fro till == 0 then begin
     ret := !ret + 1;
			  add_cutpoint p;				
      copy_variable p x p.bound;
    end;	
  done;
  !ret,p		
end
  


let make_new_cell (lx:Label.t) (p:t) (thi:int): t list = begin
  assert( Label.is_local lx );
  let x = index p thi lx in
	(*print_int x;  print_string "\n";	*)
	_kill p x;
  p.scope.(x).(0) <- 2;
  for i=0 to p.bound do
    if i <> x then begin 
			 p.heap.(i).(x) <- Info.none;
			 p.heap.(x).(i) <- Info.none;
	  end;
  done;
	p.heap.(x).(x) <- Info.equal;
	[p]
end

let next_equality (lx:Label.t) (ly:Label.t) p thi : t list = begin
    (* x.next == y *)
    []
end

(*let inNextReference (lx:Label.t) p thi : t list = begin
    (* x.next is undefined *)
		let x= index p thi lx in
		let res = ref 0 in
		for i=1 to p.bound do
     if i <> x then 
		  begin 
			if Info.is_reach p.heap.(x).(i) == 0 then 
		     res := 1
	    end;
		done;
		if !res == 0 then 
			[p]
		else
      []
end
*)

let inNextReference (lx:Label.t) p thi : t list = begin
    (* x.next is undefined *)
		let x= index p thi lx in
			if Info.is_reach p.heap.(x).(0) == 0 then 
				[p]
		else
      []
end


let nextReference (lx:Label.t) p thi : t list = begin
    (* x.next is defined *)
				
		let x= index p thi lx in
		let res = ref 1 in
		for i=0 to p.bound do
    if i <> x then 
		  begin 
      if Info.is_reach p.heap.(x).(i) == 0 && Info.is_reach p.heap.(x).(0) <> 0 then 
		     res := 0
	    end;
		done;
		if !res == 0 then 
			[p]
		else
      []
       end

let equality (lx:Label.t) (ly:Label.t) p thi : t list = begin
    (* x == y *)
		let x,y = index p thi lx, index p thi ly in	
			if Info.is_equal p.heap.(x).(y) == 0  then 
			[p]
		else
      []
end
  
let data_equality (lx:Label.t) (d:int) p thi : t list = begin
    (* x == y *)
		strengthen p;
		let x = index p thi lx in	
			if p.data.(x).(0) == d  then 
			[p]
		else
      []
end  
  
let data_inequality (lx:Label.t) (d:int) p thi : t list = begin
    (* x == y *)
		strengthen p;
		let x = index p thi lx in	
  if p.data.(x).(0) <> d  then 
			[p]
		else
      []
end  
    
let less_than (lx:Label.t) (ly:Label.t) p thi : t list = begin
    (* x < y *)
		strengthen p;
		let x,y = index p thi lx, index p thi ly in
		
		if Info.ord p.heap.(x).(y) == 2  then 
			[p]
		else
	  if Info.ord p.heap.(x).(y) == 3 && Info.ord p.heap.(y).(x) == 3 then
			begin 
				p.heap.(x).(y) <- Info.update_ord p.heap.(x).(y) 2;
				ord_strengthen p;
		  [p]
			end
		else
      []
end

let data_equality_variable (lx:Label.t) (ly:Label.t) p thi : t list = begin
    (* x < y *)
		strengthen p;
		let x,y = index p thi lx, index p thi ly in
		
		if Info.ord p.heap.(x).(y) == 0  then 
			[p]
		else
	  if Info.ord p.heap.(x).(y) == 3 then
			begin 
				p.heap.(x).(y) <- Info.update_ord p.heap.(x).(y) 0;
				ord_strengthen p;
		  [p]
			end
		else
      []
end

let in_equality (lx:Label.t) (ly:Label.t) p thi : t list = begin
    (* x != y *)
		let x,y = index p thi lx, index p thi ly in	
			if Info.is_equal p.heap.(x).(y) == 1 then 
			[p]
		else
      []
end



let kill_all_cutpoints p = begin
  (* print_string "begin--------------------- "; print_cons p;*)
  for i =  p.bound downto p.gvar + (Array.length(p.vars)) do
  (* print_string "BEGIN SMALL CUT--------------------- "; print_int i;print_cons p; *)
		if is_cutpoint p i <> 0 then 
    begin  (*print_string " cut point nay "; print_int i; print_cons p; *)
			_kill p i;
     kill_cutpoints p i;
      (*  print_string "AFTER KILLING CUTPOINT nay"; print_cons p;*)
			end;
	done;
  
  (* print_string "ennnnn--------------------- ";*)
end 

let dot_next_assign (lx:Label.t) (ly:Label.t) (p:t) (thi:int) : t list = begin
  (* x.next := y *)

	(*  if p.threads.(0).pc == 5 then print_cons p;*)
  let x,y = index p thi lx, index p thi ly in
  assert( x <> y );
  p.heap.(x).(y) <- Info.dot_next_assign p.heap.(x).(y) 2;
	(*remove previous relation of x*)
	for k = 0 to p.bound do
		if Info.is_equal p.heap.(k).(x) == 0 then
	    for i = 0 to p.bound do
		    if i <> y && Info.is_reach p.heap.(k).(i) == 0 then
				  p.heap.(k).(i) <- Info.none
	   done;
	done;

  strengthen p;
   
  (*if p.bound < 10 then kill_all_cutpoints p;*)
  (* print_string "begin--------------------- "; print_cons p;*)
  if p.bound < 10 then kill_all_cutpoints p;
   (*print_string "---------------------ennnnn ";*)
	  if p.threads.(0).pc == 5 then print_cons p;
	[p];   
end
  
let dot_next_assign_dot_next (lx:Label.t) (ly:Label.t) (p:t) (thi:int) : t list = begin
  (* x.next := y.next *)
  kill_all_cutpoints p;
  
  let x,y' = index p thi lx, index p thi ly in
  let t = ref (p.bound +1) in
  for i = 0 to p.bound do
    if Info.is_reach p.heap.(y').(i) == 0 then
      t := i; 
  done;
  assert(!t <> p.bound + 1);
  let y = !t in
  p.heap.(x).(y) <- Info.dot_next_assign p.heap.(x).(y) 2;
	(*remove previous relation of x*)
	for k = 0 to p.bound do
		if Info.is_equal p.heap.(k).(x) == 0 then
	    for i = 0 to p.bound do
		    if i <> y && Info.is_reach p.heap.(k).(i) == 0 then
				  p.heap.(k).(i) <- Info.none
	   done;
	done;
   
	(*print_string "du ma la vay--------"; print_cons p;*)
  strengthen p;

  kill_all_cutpoints p;		
	 (* if p.threads.(0).pc == 5 then print_cons p;*)
   
  [p];     
end  
  
let data_assign (lx:Label.t) (d:int) p thi : t list = begin
  (* x.data := d *)
  (*if (p.bound > 10) then print_string "truoc khi 19"; print_cons p; *)
		let x = index p thi lx in	
  p.data.(x).(0) <- d;
  strengthen p;
   (*if (p.bound > 10) then print_string "sau khi 19"; print_cons p;*) 
  
			[p]
end


let assign_dot_next (lx:Label.t) (ly:Label.t) (p:t) (thi:int) : t list = begin

  (* x := y.next *)
  	let result = ref [] in
	
		let x,y = index p thi lx, index p thi ly in
  (*if p.threads.(0).pc == 109 then begin print_string "before assign"; print_cons p; print_int x; print_int y;end;*)
		let newy = ref (p.bound+1) in
		if Info.is_reach p.heap.(y).(x) == 0 then 
		begin
			add_cutpoint p;				
    copy_variable p x p.bound; 
    				   
			
  end;
	
			

			
		let c = clone p in  

		(*print_string "after KILL pred"; print_int y; print_cons c; *)
		let z = ref (p.bound + 1) in
		(*Find desternitation of y and set these paths to none*)
		for i = 0 to c.bound do
        if Info.is_reach c.heap.(y).(i) == 0 && i <> x then begin z := i;c.heap.(y).(!z) <- Info.none end;
		done;
			(*Find desternitation of equality node as y and set these paths to none*)
		for i = 0 to c.bound do
		  	if Info.is_equal c.heap.(i).(y) == 0 then
					for j = 0 to c.bound do
		  	    if Info.is_reach c.heap.(i).(j) == 0 then c.heap.(i).(j) <- Info.none;
		done;
		done;

		(*Get the paths comming from y then do splitting*)
  (*		print_string "AFTER assign befir strengthen"; print_int y; print_int !z;  print_cons c;*)
  if Info.is_equal c.heap.(x).(y) == 0 then c.data.(x).(0) <- 0; 
 let newc1 = clone c in	
  if x <> !z then _kill c x;
  
		let cell =  p.heap.(y).(!z) in
		(*print_string "AFTER assign\n";*) 
		let a_label = Info.get_a_label cell in
		let b_label = Info.get_b_label cell in	
		let split = Info.unfold a_label b_label cell in		
	
		(*For each case of splitting*)
		for k = 0 to List.length(split)-1 do			
				let cons = List.nth split k in
		    let cons_left =  fst cons in
		    let cons_right = snd cons in
				(*create configuration matrix for that*)
    let newc = clone c in

				  newc.scope.(x).(0) <- newc.scope.(y).(0);
		      newc.heap.(y).(x) <- cons_left;
		      newc.heap.(x).(!z) <- cons_right;
					cell_expand_all newc;
          normal_strengthen newc;	
          kill_all_cutpoints newc;
					(* if p.threads.(0).pc == 109 then begin print_string "AFTER assign"; print_cons newc; print_int x; print_int y;end;*)
		      
    (*Add to result*)
      
		result := newc::!result		 
         done;  
      !result;
end



let _assign p x y = begin
  p.heap.(x).(y) <- Info.equal; (* adding x = y *)
	p.heap.(y).(x) <- Info.equal; (* adding y = x *)
	(* Copying y *)
  for i=0 to p.bound do
    if i <> x  then begin
      p.heap.(i).(x) <- p.heap.(i).(y);
      p.heap.(x).(i) <- p.heap.(y).(i); (* diagonal *)
    end;
  done;
end


let assign (lx:Label.t) (ly:Label.t) p thi : t list = begin
  (* x := y *)
  let x,y = index p thi lx, index p thi ly in
   _kill p x;
 _assign p x y;
cell_expand_all p;
          normal_strengthen p;	
  kill_all_cutpoints p;
   [p]
end

let next_mark_equality (lx:Label.t) (ly:Label.t) (d:int) p thi : t list = begin
    (* x == y *)
		let x,y = index p thi lx, index p thi ly in	
			if Info.is_reach_one p.heap.(x).(y) == 0  then 
				if List.length(Info.get_b_label p.heap.(x).(y)) == 0 && p.data.(x).(0) == d then
			   [p]
				else
				 []	
		else
      []
end

let cas_success (x:Label.t) (y:Label.t) (z:Label.t) p thi = begin
  List.fold_left (fun acc el -> (acc @ assign x z (clone el) thi)) [] (equality x y p thi)
end

let attempt_mark (x:Label.t) (y:Label.t) p thi = begin
  List.fold_left (fun acc el -> (acc @ data_assign x 1 (clone el) thi)) [] (next_mark_equality x y 0 p thi)
    
end

let attempt_mark_fail (x:Label.t) (y:Label.t) p thi = begin
 if List.length(next_mark_equality x y 0 p thi) == 0 then
		[p]
	else
		[]   
end

let cas_success_set (x:Label.t) (y:Label.t) (d:int) (z:Label.t) p thi = begin
 
  List.fold_left (fun acc el -> (acc @ dot_next_assign x z (clone el) thi)) [] (next_mark_equality x y 0 p thi)
    
end

let cas_fail_set (x:Label.t) (y:Label.t) (d:int) (z:Label.t) p thi = begin
  if List.length(next_mark_equality x y 0 p thi) == 0 then
		[p]
	else
		[]
end
  
 
  
(* No need to clone *)
let init_thread vars p thi : t list = begin
  let th = p.threads.(thi) in
  assert( th.range = 0);

  p.vars <- vars;
  let count = Array.length vars in
  let newBound = p.bound+count in
  let cut = th.lbound in (* lower bound *)
  
  let h = Array.make_matrix (newBound+1) (newBound+1) Info.none in
  let s = Array.make_matrix (newBound+1) (1) 2 in
  let d = Array.make_matrix (newBound+1) (1) 0 in
	for i=0 to p.gvar - 1 do 
	  d.(i).(0) <- p.data.(i).(0)
 done;
  	for i=0 to p.gvar - 1 do 
	  s.(i).(0) <- 0
	 done;
  for i=0 to cut - 1 do
    for j=0 to cut - 1 do (* Copy the colors and globals *) h.(i).(j) <- p.heap.(i).(j); done;
    for j=cut to p.bound do (* Taking care of the threads *) h.(i).(j+count) <- p.heap.(i).(j); done;
  done;
  
  for i=cut to p.bound do
    for j=0 to cut - 1 do h.(i+count).(j) <- p.heap.(i).(j); done;
    for j=cut to p.bound do h.(i+count).(j+count) <- p.heap.(i).(j); done;
  done;
  
  let trans = Array.make count "" in
  (* update the bounds of the thread *)
  th.range <- count;
  th.trans <- trans;
  p.bound <- newBound;
  p.heap <- h;
	p.scope <- s;
  p.data <-d;
  (* update the bounds of the other (physically after) threads *)
  for thj=thi+1 to p.nth-1 do
    let th' = p.threads.(thj) in
    th'.lbound <- th'.lbound + count;
  done;
  
  (* assign them to bottom *)
  let iBottom = index p thi Label.bottom in
  for i=cut to cut + count - 1 do
    h.(i).(i) <- Info.equal;
    _assign p i iBottom;
  done;
  [p]
end
  

  
(* No need to clone *)
let kill_thread (p:t) (thi:int) : t list = begin

  strengthen p;
	   (*print_string "Before kill \n"; print_cons p;*)
    (*print_string "After kill \n"; print_cons p;*)
    for i = p.gvar to p.bound do
    _kill p i;
	
    done;
			(* print_string "After kill \n"; print_cons p;*)
  let th = p.threads.(thi) in
  let vars = th.range in
  let newBound = p.bound - vars - p.cutpoints in
  let cut = th.lbound in (* lower bound *)

  (* Removing the thread labels *)
  for i=cut to cut + vars-1 do _kill p i; done;

  let h = Array.make_matrix (newBound+1) (newBound+1) Info.none in

  (* Copying to the new heap. AFTER the label removing!! *)
  for i=0 to cut - 1 do
    for j=0 to cut - 1 do h.(i).(j) <- p.heap.(i).(j); done;
    for j=cut to newBound do h.(i).(j) <- p.heap.(i).(j+vars); done;
  done;
  for i=cut to newBound do
    for j=0 to cut - 1 do h.(i).(j) <- p.heap.(i+vars).(j); done;
    for j=cut to newBound do h.(i).(j) <- p.heap.(i+vars).(j+vars); done;
  done;
  
  p.bound <- newBound;
	p.vars <- [||];
  p.heap <- h;
  p.cutpoints <- 0;
  (* reset the thread *)
  th.pc      <- 0;
  th.promise <- Promise.NoPromise;
  th.return  <- Data.top;
  for i=0 to Array.length th.bits - 1 do th.bits.(i) <- false done;
  th.range   <- 0;
  th.trans   <- [||];

  (* update the bounds of the other (physically after) threads *)
  for thj=thi+1 to p.nth-1 do
    let th' = p.threads.(thj) in
    th'.lbound <- th'.lbound - vars;
  done;

  [p]
end

let record_insert data p thi = begin
  set_promise p thi (Promise.Insert data);
  [p]
end

(*The function is to get the next cutpoint of the variable or cutpoin at k position*)
let r p k = begin
  let res = ref [] in
  (*  print_string " K: "; print_int k;*)
  for i = 0 to p.bound do
	if Info.is_reach p.heap.(k).(i) == 0 then
   begin res := i::!res;
     (* print_string " I: "; print_int i; Info.print_cell p.heap.(k).(i)*) end;
  done;
  (*print_string "\n";*)
  !res
end

(*Check if k position is leaf*)
let is_leaf p k = begin
  let res = ref false in
  for i = 0 to 2 do
	if Info.is_equal p.heap.(k).(i) == 0 then
		res := true;
	done;
  !res
end

let get_leaf p k = begin
  let res = ref (p.bound+1) in
  for i = 0 to 2 do
	if Info.is_equal p.heap.(k).(i) == 0 then
		res := i;
	done;
  !res
end

(*index of variable of thi(fist or second) matrix in intersection matrix*)				
let new_index p1 i thi =
	(*first matrix*)
	if thi == 1 then 
		i
	else
	 begin
	   if i >= p1.gvar then
		    i + (Array.length p1.vars + p1.cutpoints)
	   else
		    i
	 end	
	
(*check if variable at k position is global *)	
let is_global_var p k = 
	if k < p.gvar then
		true
	else
		false

(*let rec compare_path p1 p2 x y = begin
	strengthen p1;
	strengthen p2;
	if is_leaf p1 x == true && is_leaf p2 y == true then
		0
	else
	if is_leaf p1 x == true && is_leaf p2 y == false then
		1
	else
	if is_leaf p1 x == false && is_leaf p2 y  == true then
		1
	else
	if is_leaf p1 x == false && is_leaf p2 y == false then
		begin
			if List.length(r p1 x) > 0 && List.length(r p2 y) > 0 then
				begin
	       let x1, y1 = List.nth (r p1 x) 0, List.nth (r p2 y) 0 in
				 print_int x1; print_int y1; print_string "\n";
				 print_cons p1; print_cons p2; 
	       Info.compare10 p1.heap.(x).(x1) p2.heap.(y).(y1) (*lor compare_path p1 p2 x1 y1*)
				  
			  end
			else
        0
    end
	else
		0
end*)

(*let compare_content p1 p2 = begin
	let ret = ref 0 in
	(*for i = 3 to 3 (*p1.gvar -1 + (Array.length(p1.vars))*) do
	    ret := !ret lor compare_path p1 p2 3 3
	done;
	!ret*)
	
	compare_path p1 p2 3 3
end
*)


let get_bigest_incomming p x = begin
	  let ret = ref (0) in
  for i = (p.bound-p.cutpoints) downto 0 do
			  if (Info.is_reach p.heap.(i).(x)) == 0 then 
					ret := i;
		done;
		!ret
end

let order p cutpoints = begin
	List.sort (fun x y -> if (get_bigest_incomming p x) > (get_bigest_incomming p y) then 1 else 0) cutpoints;
end

let permutation p i = begin

  if p.cutpoints == 0 then i else begin
    if i <= p.bound - p.cutpoints then i
	else
		let cutpoints_list = 
			let list = ref [] in			 
    for k = p.bound - p.cutpoints + 1 to p.bound do
				  list := !list@[k]
			done;
			!list in
		let order_cutpoints_list = order p cutpoints_list in
		let ret = ref (p.bound +1) in
		for k = 0 to List.length(cutpoints_list) - 1 do
			if i == List.nth cutpoints_list k then
				  ret := List.nth order_cutpoints_list k
		done;
    !ret
  end;
  
end
let order_index i p1 p2 = begin
  
  let ret = ref (p2.bound + 1) in
  if i > p2.bound - p2.cutpoints then begin
  let i1 = permutation p1 i in
  for k = p2.bound-p2.cutpoints + 1 to p2.bound do
    if permutation p2 k == i1 then
      ret := k
  done;
  end
  else
    ret := i;
  !ret
end 
let compare_content p1 p2 thi = begin
	let org_time1  = Sys.time () in   
  if p1.cutpoints <> p2.cutpoints then
		1
  else
      if p1.bound <> p2.bound then
		1
  else
    try
     for i=0 to p1.bound  do 
     for j= 0 to p1.bound  do 
       if Info.compare10 p1.heap.(i).(j) p2.heap.(order_index i p1 p2).(order_index j p1 p2) <> 0 then raise (BreakLoop 0);
		done;
     done;
		    raise (BreakLoop 1);
      with (BreakLoop 0) -> 1
      |     
   	       (BreakLoop 1) -> 0	
end


let compare_world_0 p1 p2 = begin
  (*print_string "let compare\n";print_int p1.threads.(0).pc;print_int p2.threads.(0).pc;*)
	assert( Observer.same_state p1.observer p2.observer );
  try
		if inspect_gworld p1 p2 == 1 then 1 else
		begin		
		let th1, th2 = p1.threads.(0), p2.threads.(0) in		
    if Pervasives.compare th1.pc th2.pc == 0 then
       compare_content p1 p2 0
		else
		   1
		end	    
  with Compare i -> i	
end

let compare_world_1 p1 p2 = begin
  (*print_string "let compare\n";print_int p1.threads.(0).pc;print_int p2.threads.(0).pc;*)
	assert( Observer.same_state p1.observer p2.observer );
  try
		if inspect_gworld p1 p2 == 1 then 1 else
		begin		
		let th1, th2 = p1.threads.(0), p2.threads.(0) in		
    if (th1.pc == 1013 && th2.pc == 1020) || (th1.pc == 13 && th2.pc == 1020)  then
       compare_content p1 p2 0
		else
		   1
		end	    
  with Compare i -> i	
end

(*Intersection of two label*)
let rec intersect_label a b = 	
	  let map_element e1 e2 = begin
			let check = ref 0 in
     for i = 0 to List.length(e1) -2 do 
       if List.nth e1 i <> List.nth e2 i then begin  check := 1; end; 
			done;
     if !check == 0 then
       begin
         if  List.nth e1 (List.length(e1)-1) == List.nth e2 (List.length(e1)-1) then
           e1
         else
           if List.nth e1 (List.length(e1)-1) == 2 then
             e2
           else
             if List.nth e2 (List.length(e2)-1) == 2 then
               e1
             else
               []
       end
			else
    
     [] 
   end in
	  let rec _intersect x b = match b with
		| [] -> [] 
		| hd::tl -> let newhd = map_element x hd in if List.length(newhd) > 0 
		                                            then newhd::_intersect x tl else _intersect x tl in
		match a with 
		| [] -> [] 
		| hd::tl -> (_intersect hd b) @ (intersect_label tl b)


(*The fist case of matching two path when doing insersection*)
(* r(i1,i2) = r(r(i1), r(i2)) *)
let match_1 p1 p2 i1 i2 i3 = begin
  (*print_string "begin match 1\n";print_int i1;print_int i2; print_string "\n";	
		print_cons p1;
     print_cons p2;*)
   p1.heap.(0).(0) <- Info.equal;
   p2.heap.(0).(0) <- Info.equal;  
	 let r1,r2 = List.nth (r p1 i1) 0, List.nth (r p2 i2) 0 in
  (*print_string "midde match 1\n"; print_int r1;print_int r2; print_string "\n";*)		
		(*label is b1 /\ b2 /\ a1 /\ a2 *)
		let b_label = let b_label_1 = Info.get_b_label p1.heap.(i1).(r1) in 
		              let b_label_2 = Info.get_b_label p2.heap.(i2).(r2) in 
								  intersect_label b_label_1 b_label_2 in								
									
		let a_label = let a_label_1 = Info.get_a_label p1.heap.(i1).(r1) in 
		              let a_label_2 = Info.get_a_label p2.heap.(i2).(r2) in 
									if List.length (intersect_label [a_label_1] [a_label_2]) <> 0 then
								     List.nth (intersect_label [a_label_1] [a_label_2]) 0 
									else
										[]
									in
			
		if List.length(a_label) <> 0 then		
			   ((r1,r2), (a_label,b_label), (i3,r1)), true
		else
      (*let u = 0 in print_string "end =====================================match 1\n"; print_int r1;print_int r2; print_string "\n";*)	
			   ((r1,r2), (a_label,b_label), (i3,r1)), false
end

(*The second case of matching two path when doing insersection*)
(* r(i1,i2) = r(r(i1), i2) *)
let merge_label a = begin
	if List.length(a) == 2 then
		let l = List.nth a 0 in
	[([List.nth l 0] @ [List.nth l 1] @ [2])] 
	else
		a
end
let match_2 p1 p2 i1 i2 i3 = begin
	  let r1,r2 = List.nth (r p1 i1) 0, i2 in
		(*label is b1 /\ b2 /\ a1 /\ a2 *)
	
		let b_label = let b_label_1 = Info.get_b_label p1.heap.(i1).(r1) in 
		              let b_label_2 = Info.get_b_label p2.heap.(i2).(List.nth (r p2 i2) 0) in 
									
								  intersect_label b_label_1 b_label_2 in
		let a_label = let a_label_1 = Info.get_a_label p1.heap.(i1).(r1) in 
	              	let b_label_2 = Info.get_b_label p2.heap.(i2).(List.nth (r p2 i2) 0) in 
									
									if List.length (intersect_label  [a_label_1] b_label_2) <> 0 then
		                 List.nth (intersect_label  [a_label_1] b_label_2) 0 
									else
										[]
									in	
    if List.length(Info.get_b_label p2.heap.(i2).(List.nth (r p2 i2) 0)) == 0 then
       ((r1,r2), (a_label,b_label), (i3,r1)),false
       else
		if List.length(a_label) <> 0  then											
		     ((r1,r2), (a_label,b_label), (i3,r1)), true
		else
			   ((r1,r2), (a_label,b_label), (i3,r1)), false
end

(*The third case of matching two path when doing insersection*)
(* r(i1,i2) = r(i1, r(i2)) *)
let match_3 p1 p2 i1 i2 i3 = begin
	  let r1,r2 = i1, List.nth (r p2 i2) 0 in
		(*label is b1 /\ b2 /\ a1 /\ a2 *)
		let b_label = let b_label_1 = Info.get_b_label p1.heap.(i1).(List.nth (r p1 i1) 0) in 
		              let b_label_2 = Info.get_b_label p2.heap.(i2).(r2) in 
								  intersect_label b_label_1 b_label_2 in
		let a_label = let a_label_2 = Info.get_a_label p2.heap.(i2).(List.nth (r p2 i2) 0) in 
		              let b_label_1 = Info.get_b_label p1.heap.(i1).(List.nth (r p1 i1) 0) in 
									if List.length (intersect_label [a_label_2] b_label_1) <> 0 then List.nth (intersect_label [a_label_2] b_label_1) 0 
									else
             (*let t = 0 in print_string "khong bang nhau day nay"; print_int (List.length(b_label_1)); print_string " "; print_int (List.length([a_label_2])); print_string " \n";  
              *)      
               []
									in
    if List.length(Info.get_b_label p1.heap.(i1).(List.nth (r p1 i1) 0)) == 0 then
			 ((r1,r2), (a_label,b_label), (i3,r1)),false
       else
		if List.length(a_label) <> 0	 then											
		     ((r1,r2), (a_label,b_label), (i3,r2)), true
		else   
			   ((r1,r2), (a_label,b_label), (i3,r2)), false
end


(* update matrix with a cell *)
let _update p a b x y = 
let cell = Info.create_cell a b in
p.heap.(x).(y) <- cell;
p 

(* update matrix with a cell *)
let _direct_update p a b x y = begin
let cell = Info.create_cell a b in
p.heap.(x).(y) <- cell
end

(*//////////////////////////////////////////////////////////////////Abstract Away//////////////////////////////////////////////////////////////////*)
let abstract_away p fro till p1 = begin	
	  let org_time1 = Sys.time () in  
	
  let cutpoints,p' = (_add_cutpoint p fro till) in	 
		for i = fro+1 to till do
    _mergeover p' i fro till;
	done; 
  let newbound = p1.bound + cutpoints in
	(*the matrix after abstracting will be same as p1 in structure*)
  let newp = clone p1 in
  newp.threads.(0).pc <- p'.threads.(0).interf_pc;
	 let newheap = Array.make_matrix (newbound+1) (newbound+1) Info.none in
	 let newscope = Array.make_matrix (newbound+1) 1 0 in
	 let newsdata = Array.make_matrix (newbound+1) 1 0 in
	 (*Update scope  of variables*)

	 for i = 0 to p.bound do
		   if i <= fro then begin
       newscope.(i).(0) <- p'.scope.(i).(0); newsdata.(i).(0) <- p'.data.(i).(0); end
			 else
				 if i > till then
       begin newscope.(i-(till - fro)).(0) <- p'.scope.(i).(0); newsdata.(i-(till - fro)).(0) <- p'.data.(i).(0); end
	 done;
  (*print_string "after==============:";*)
	 newp.bound <- newbound;
	 newp.heap <- newheap;
	 newp.scope <- newscope;
	 newp.data <-newsdata;
  newp.cutpoints <- p1.cutpoints + cutpoints;

		let org_time2 = Sys.time () in   
  (* print_string "after ssss==========:"; print_cons p'; print_int (till-fro); print_cons newp;print_int p'.bound;*)
	(*Update matrix*)
  for i = 0 to p'.bound do
    for j = 0 to p'.bound do
		if i <= fro then 
		 begin
		  if j <= fro then
      newp.heap.(i).(j) <- p'.heap.(i).(j)
		  else
			 if j > till then
       newp.heap.(i).(j - (till - fro)) <- p'.heap.(i).(j)
		 end
		else
		 if i > till then 
			begin
		   if j <= fro then
       newp.heap.(i- (till - fro)).(j) <- p'.heap.(i).(j)
		   else
			  if j > till then
       newp.heap.(i- (till - fro)).(j - (till - fro)) <- p'.heap.(i).(j)
		  end
    done;
  done;
  kill_all_cutpoints newp;
  (*Debug.print " abstract in second part %.2f\n" ((Sys.time ()) -. org_time1);  *)
  newp

end



let local_roots p = begin
	  let local_nodes = ref [] in
	  for i = 0 to p.bound do
			if p.scope.(i).(0) == 1 then begin
				let is_local = ref 0 in
				for j = 0 to p.bound do
				    if (j <> i) then
							if Info.is_reach p.heap.(j).(i) == 0 && p.scope.(j).(0) <> 2 then
								is_local := 1;
				done; 
				if !is_local == 0 then
					local_nodes := i::!local_nodes;  
			end;
		 done;
		!local_nodes
end

let rec local_paths p i = begin
	if  p.scope.(i).(0) == 0 then
		[i]
	else
	let output = r p i in
	  if List.length(output) > 0 then
	   i:: local_paths p (List.nth output 0)
		else
		 []
end

let remove_duplicates l =
  let open List in
  let tbl = Hashtbl.create (length l) in
  let f l e = 
    try 
      let _ = Hashtbl.find tbl e in l
    with
    | Not_found -> 
      Hashtbl.add tbl e ();
      e::l
  in
  List.rev (List.fold_left f [] l)

(*get paths from k to j*)
let get_path_label l p k j = begin
	if List.nth l k <= p.bound && List.nth l j <= p.bound then 
			begin
				 (* print_string "begin-------------------------- 1\n"; print_int k; print_int j;*)
					
	     let a_label = if List.nth l (j-1) <= p.bound then Info.get_a_label p.heap.(List.nth l (j-1)).(List.nth l j) else Info.get_a_label p.heap.(List.nth l (j-2)).(List.nth l j) in
			 (*print_string "get a_label from get_path_function"; print_int (List.nth l (j-1)); print_int (List.nth l (j)); print_int (List.length(a_label)); Info.print_label a_label;*)
		   let b_label = ref [] in
		   for t = k to j-2 do
	       let b_label_t = if List.nth l (t+1) <= p.bound then Info.get_b_label p.heap.(List.nth l t).(List.nth l (t+1)) else Info.get_b_label p.heap.(List.nth l t).(List.nth l (t+2)) in
			   let a_label_t = if List.nth l (t+1) <= p.bound then Info.get_a_label p.heap.(List.nth l t).(List.nth l (t+1)) else Info.get_a_label p.heap.(List.nth l t).(List.nth l (t+2)) in
			   let merge_a_b_t =  [a_label_t] @ b_label_t in
			   b_label := merge_a_b_t @ !b_label 
       done;
			 							(*	  print_string "end--------------------------- 1\n";*)
       let b_label_last = if List.nth l (j-1) <= p.bound then Info.get_b_label p.heap.(List.nth l (j-1)).(List.nth l j) else Info.get_b_label p.heap.(List.nth l (j-2)).(List.nth l j) in
			 b_label := remove_duplicates (b_label_last @ !b_label) ;

			 ([a_label], !b_label)
			end
	 else			
	if List.nth l k > p.bound && List.nth l j <= p.bound then 
			begin
								(*  print_string "begin-------------------------- 2\n";*)
			  if k < j - 1 then 
				  begin
	          let a_label = Info.get_a_label p.heap.(List.nth l (j-1)).(List.nth l j) in
		        let b_label = ref [] in
		        for t = k+1 to j-2 do				 
	            let b_label_t = Info.get_b_label p.heap.(List.nth l t).(List.nth l (t+1)) in
			        let a_label_t = Info.get_a_label p.heap.(List.nth l t).(List.nth l (t+1)) in
			        let merge_a_b_t =  [a_label_t] @ b_label_t in
			        b_label := merge_a_b_t @ !b_label 
            done;
            let b_label_last = Info.get_b_label p.heap.(List.nth l (j-1)).(List.nth l j) in
			      b_label := b_label_last @ !b_label;
			      let b_label_k = Info.get_b_label p.heap.(List.nth l (k-1)).(List.nth l (k+1)) in
			      let a_label_k = Info.get_a_label p.heap.(List.nth l (k-1)).(List.nth l (k+1)) in
			      let merge_a_b_k =  [a_label_k] @ b_label_k in
			      b_label := remove_duplicates (merge_a_b_k @ !b_label); 
						(* print_string "end-------------------------- 2\n";*)
            ([a_label], !b_label)
			  end
			  else
				   let a_label = Info.get_a_label p.heap.(List.nth l (k-1)).(List.nth l j) in
		       let b_label = Info.get_b_label p.heap.(List.nth l (k-1)).(List.nth l j) in
									(*  print_string "end-------------------------- 2\n";*)
           ([a_label], b_label)
		end
		else
   if List.nth l k <= p.bound && List.nth l j > p.bound then 
			begin
								 (* print_string "begin-------------------------- 3\n";*)
	     let a_label = Info.get_a_label p.heap.(List.nth l (j-1)).(List.nth l (j+1)) in
		   let b_label = ref [] in
					
		   for t = k to j-2 do
	       let b_label_t = Info.get_b_label p.heap.(List.nth l t).(List.nth l (t+1)) in
			   let a_label_t = Info.get_a_label p.heap.(List.nth l t).(List.nth l (t+1)) in
			   let merge_a_b_t =  [a_label_t] @ b_label_t in
			   b_label := merge_a_b_t @ !b_label 
       done;
       let b_label_last = Info.get_b_label p.heap.(List.nth l (j-1)).(List.nth l (j+1)) in
							 (* print_string "end-------------------------- 3\n";*)
			 b_label := remove_duplicates (b_label_last @ !b_label) ;
		   ([a_label], !b_label)
			end
		else	
	if List.nth l k > p.bound && List.nth l j > p.bound then 
		begin
							(*  print_string "begin-------------------------- 4\n";*)
	     let a_label = Info.get_a_label p.heap.(List.nth l (j-1)).(List.nth l (j+1)) in
		   let b_label = ref [] in					
		   for t = k-1 to j-2 do
	       let b_label_t = Info.get_b_label p.heap.(List.nth l t).(List.nth l (t+1)) in
			   let a_label_t = Info.get_a_label p.heap.(List.nth l t).(List.nth l (t+1)) in
			   let merge_a_b_t =  [a_label_t] @ b_label_t in
			   b_label := merge_a_b_t @ !b_label 
       done;
       let b_label_last = Info.get_b_label p.heap.(List.nth l (j-1)).(List.nth l (j+1)) in
							(*  print_string "end-------------------------- 4\n";*)
			 b_label := remove_duplicates (b_label_last @ !b_label) ;
			 ([a_label], !b_label)
	 end
	else
		([],[])
		
end

let update_cons_from_local_intersect p1 p2 l1 l2 paths = begin
	let p1' = clone p1 in
	let p2' = clone p2 in
	(*Create new cutpoints according to number of cutpoints in paths for p1 and p2*)
  for k = 0 to List.length(l1) - 1 do
	  if List.nth l1 k > p1.bound then 
			add_cutpoint p1';
		done;
		for k = 0 to List.length(l2) - 1 do
		if List.nth l2 k > p2.bound then
			add_cutpoint p2';
	done;
	for k = 0 to List.length(paths) - 2 do
		let pair_pre = List.nth paths k in
		let i1,j1 = fst pair_pre, snd pair_pre in
		let pair_succ = List.nth paths (k+1) in
		let i2,j2 = fst pair_succ, snd pair_succ in
		let (a_label_i, b_label_i) = get_path_label l1 p1 i2 i1 in
		let (a_label_j, b_label_j) = get_path_label l2 p2 j2 j1 in
		let new_a_label = intersect_label a_label_i a_label_j in
		let new_b_label = intersect_label b_label_i b_label_j in
		(*Update paths in l2 paths of p2*)
		for j = j2 to j1-1 do
			let (old_a_label,old_b_label) = get_path_label l2 p2 j (j+1) in
			if j < j1-1 then
				begin
				  let a_label = intersect_label new_b_label old_a_label in 
				  let b_label = intersect_label new_b_label old_b_label in
				  if List.length(a_label) > 0 then 
				   let cell = Info.create_cell (List.nth a_label 0) b_label in
					  (*Reset path comming from j*)
						for t = 0 to p2.bound do
							if Info.is_reach p2'.heap.(List.nth l2 j).(t) == 0 then p2'.heap.(List.nth l2 j).(t) <- Info.none;
						done;
						p2'.heap.(List.nth l2 j).(List.nth l2 (j+1)) <- cell
				end
			else
				let a_label = intersect_label new_a_label old_a_label in 
				let b_label = intersect_label new_b_label old_b_label in
				if List.length(a_label) > 0 then 
				   let cell = Info.create_cell (List.nth a_label 0) b_label in
					 	for t = 0 to p2'.bound do
							if Info.is_reach p2'.heap.(List.nth l2 j).(t) == 0 then p2'.heap.(List.nth l2 j).(t) <- Info.none;
						done;
						p2'.heap.(List.nth l2 j).(List.nth l2 (j+1)) <- cell;
		done;
		(*Update paths in l1 paths of p1*)
		p1'.heap.(List.nth l1 i2).(List.nth l1 i1) <- Info.none;
	done;
	(*print_string "\nLet see what happen with two constraints: \n";
	print_string "this is p1\n";
	print_cons p1';
	print_string "this is p2\n";
	print_cons p2';*)
	(p1', p2')
end

 let local_intersect l1 l2 p1 p2 = begin
	let leaf1, leaf2 = List.length(l1)-1, List.length(l2)-1 in
	let pairs_list = ref [[(leaf1,leaf2)]] in
	 let rec map l1 l2 pl start p1 p2 = begin
		let newstart = List.length(!pl) in
		for k = start to List.length(!pl)-1 do
			let curr = List.nth !pl k in
			let last_pair_in_curr = List.nth curr (List.length(curr)-1) in
  		let i,j = fst last_pair_in_curr, snd last_pair_in_curr in
			if i >= 1 then				
			   for j' = j-1 downto 0 do
					 let (a_label_i, b_label_i) = get_path_label l1 p1 (i-1) i in
					 let (a_label_j, b_label_j) = get_path_label l2 p2 j' j in
					 let new_a_label = intersect_label a_label_i a_label_j in
					 let new_b_label = intersect_label b_label_i b_label_j in
					 if List.length(new_a_label) > 0 then
						 if j'== j-1 then
               pl := !pl@[curr@[(i-1,j')]]
						 else
							 if List.length(new_b_label) > 0 then
								 pl := !pl@[curr@[(i-1,j')]];
							 
		     done;
		done;	
		if newstart < List.length(!pl) then
			map l1 l2 pl newstart	p1 p2
	 end in
	map l1 l2 pairs_list 0 p1 p2;
	!pairs_list
		(*	print_string "\nMapping couple are below:\n";
		for i = 0 to List.length(!pairs_list)-1 do
		let current = List.nth !pairs_list i in
    print_string "\n";
		 for j = 0 to List.length(current)-1 do
			let pair = List.nth current j in
			  print_int (List.nth l1 (fst pair)); print_int (List.nth l2 (snd pair)); print_string "  ";
		 done;
	done;*)
end

let make_up l p = begin
	let ret = ref [List.nth l (List.length l -1)] in
	for i = List.length l - 2 downto 0 do
		let path = p.heap.(List.nth l i).(List.nth l (i+1)) in
		let b_label = Info.get_b_label path in		
		if List.length b_label == 0 then
			 ret := (List.nth l i)::!ret
		else
		  let cutpoint = p.bound + 1 in (*Change it later to paramester*)
		  ret := (List.nth l i) :: cutpoint:: !ret;
	done;

		 (*  print_string "\nafter making up\n";
	  for i = 0 to List.length !ret - 1 do
		print_int (List.nth !ret i); print_string " ";
		done;*)
	  !ret
end	 

let compare_leaf p1 p2 leaf1 leaf2 = begin
	 let ret = ref 1 in
   for i = 0 to 3 do
		if Info.is_equal p1.heap.(leaf1).(i) == 0 && Info.is_equal p2.heap.(leaf2).(i) == 0 then
			ret := 0
	done;
	!ret
end

(*
let update_local_paths p1 p2 = begin
  let roots1 = local_roots p1 in
	let ret = ref [] in
	let paths1 = if (List.length(roots1) > 0) then local_paths p1 (List.nth roots1 0) else [] in
  let roots2 = local_roots p2 in
	let paths2 = if (List.length(roots2) > 0) then local_paths p2 (List.nth roots2 0) else [] in
	if List.length(paths1) > 0 && List.length(paths2) > 0  then begin
		let leaf1, leaf2 = List.length(paths1)-1, List.length(paths2)-1 in
		if compare_leaf p1 p2 leaf1 leaf2 == 0 then begin
	  print_cons p1;
		print_cons p2;
		print_string "------------two paths are considered-------------\n";
		print_string "paths 1: ";
		for i = 0 to List.length(paths1) - 1 do
					  print_int (List.nth paths1 i)
					done;
		print_string "\npaths 2: ";
		for i = 0 to List.length(paths2) - 1 do
					  print_int (List.nth paths2 i)
		done;		
		(*Get mapping pair of two paths*)			
		print_string "\nMaping of two paths: \n";
		let full_paths1, full_paths2 = make_up paths1 p1, make_up paths2 p2 in
		
		(*Go through the pair_list to consider all possible mapping paths*)
		let pairs_list = local_intersect full_paths1 full_paths2 p1 p2 in
			for i = 0 to List.length(pairs_list)-1 do
				print_string "Maping: ";
		    let current = List.nth pairs_list i in
		    for j = 0 to List.length(current)-1 do
			    let pair = List.nth current j in
			    print_int (List.nth full_paths1 (fst pair)); print_string "--"; print_int (List.nth full_paths2 (snd pair)); print_string "  ";
		    done;
		    let (p1',p2') = update_cons_from_local_intersect p1 p2 full_paths1 full_paths2 current in
		      ret := (p1',p2')::!ret;
	     done;
		  end;
		end;	
		!ret		
end
*)


(*let _extends p1 p2 = begin
	 let ret = ref [] in
   let p = update_local_paths p1 p2 in
	 for i = 0 to List.length(p) - 1 do
		let (p1',p2') = List.nth p i in
		let p = _extend p1' p2' in
		ret := p::!ret;
	 done;
	 !ret
end
*)


(*Extend the two configurations into one*)
let _extend p1 p2 = begin
	let bound = p1.bound + (Array.length p2.vars) + p2.cutpoints in
	let h = Array.make_matrix (bound+1) (bound+1) Info.none in
	let p = clone p1 in

	for i = 0 to bound do
		for j = 0 to bound do
			if i <= p1.bound && j <= p1.bound && (Info.is_equal p1.heap.(i).(j) == 0 || Info.is_none p1.heap.(i).(j) == 0) then
			      h.(i).(j) <-  p1.heap.(i).(j) ;
			
			if i > p1.bound && j > p1.bound && ((Info.is_equal p2.heap.(i-Array.length p1.vars - p1.cutpoints).(j-Array.length p1.vars- p1.cutpoints)) == 0 || (Info.is_none p2.heap.(i-Array.length p1.vars - p1.cutpoints).(j-Array.length p1.vars- p1.cutpoints)) == 0) then
			      h.(i).(j) <- p2.heap.(i-Array.length p1.vars - p1.cutpoints).(j-Array.length p1.vars- p1.cutpoints);
			
			if i > p1.bound && j < p1.gvar  && ((Info.is_equal p2.heap.(i-Array.length p1.vars- p1.cutpoints).(j)) == 0 || (Info.is_none p2.heap.(i-Array.length p1.vars- p1.cutpoints).(j)) == 0) then
			      h.(i).(j) <- p2.heap.(i-Array.length p1.vars- p1.cutpoints).(j);
			
			if i < p1.gvar && j > p1.bound  && ((Info.is_equal p2.heap.(i).(j-Array.length p1.vars- p1.cutpoints)) == 0 || (Info.is_none p2.heap.(i).(j-Array.length p1.vars- p1.cutpoints)) == 0) then
			      h.(i).(j) <- p2.heap.(i).(j-Array.length p1.vars- p1.cutpoints);
			
			if i > p1.bound && j < p1.gvar  && p2.scope.(i-Array.length p1.vars- p1.cutpoints).(0) >= 1 then
			      h.(i).(j) <- p2.heap.(i-Array.length p1.vars - p1.cutpoints).(j);
			
			if i > p1.bound && j > p1.bound  && p2.scope.(i-Array.length p1.vars- p1.cutpoints).(0) >= 1 then
			      h.(i).(j) <- p2.heap.(i-Array.length p1.vars - p1.cutpoints).(j-Array.length p1.vars- p1.cutpoints);
			
			if i <= p1.bound && j <= p1.bound && p1.scope.(i).(0) >= 1 then
			      h.(i).(j) <- p1.heap.(i).(j);
			
	  done;
	done;
	p.heap <- h;
	p.bound <- bound;
	p.vars <- Array.append p1.vars p2.vars;
	p.cutpoints <- p2.cutpoints;
	p.translation = p1.translation;
	(*Extend the scope of variables of the two configurations*)
	let scope = Array.make_matrix (bound+1) 1 0 in
	let data = Array.make_matrix (bound+1) 1 0 in
  for i = 0 to bound do
	if i < p1.gvar + (Array.length p1.vars + p1.cutpoints) then begin
	    scope.(i).(0) <- p1.scope.(i).(0); data.(i).(0) <- p1.data.(i).(0); end
	else 
		begin
		  scope.(i).(0) <- p2.scope.(i - (Array.length p1.vars) - p1.cutpoints).(0); data.(i).(0) <- p2.data.(i - (Array.length p1.vars) - p1.cutpoints).(0); 
		end;
	done;
	p.scope <- scope;
	p.data <- data;
	(*update intersection pc to pc of p2, it will be used as pc after abstraction away*)
	p.threads.(0).interf_pc <- p2.threads.(0).pc; 
	(*print_string "EXTEBD=================================================================================================================================================================================================================================";
	print_cons p;*)
	p
end


let extends_and_update_local_paths p1 p2 = begin
  (*let roots1 = local_roots p1 in
	let ret = ref [] in
	let paths1 = if (List.length(roots1) > 0) then local_paths p1 (List.nth roots1 0) else [] in
  let roots2 = local_roots p2 in
	let paths2 = if (List.length(roots2) > 0) then local_paths p2 (List.nth roots2 0) else [] in
	if List.length(paths1) > 0 && List.length(paths2) > 0  then begin
		let leaf1, leaf2 = List.length(paths1)-1, List.length(paths2)-1 in
		if compare_leaf p1 p2 leaf1 leaf2 == 0 then begin
		let full_paths1, full_paths2 = make_up paths1 p1, make_up paths2 p2 in		
		(*Go through the pair_list to consider all possible mapping paths*)
		let pairs_list = local_intersect full_paths1 full_paths2 p1 p2 in
			for i = 0 to List.length(pairs_list)-1 do
		    let current = List.nth pairs_list i in
		    let (p1',p2') = update_cons_from_local_intersect p1 p2 full_paths1 full_paths2 current in
				  let p = _extend p1' p2' in
					(*Update eualily between mapping pair for p*)
					for j = 0 to List.length(current)-1 do
			       let pair = List.nth current j in
						 let left_var =  List.nth full_paths1 (fst pair) in
						 let right_var = List.nth full_paths2 (snd pair) in 
						 (*print_string "mapping pair: "; print_int left_var; print_string "-"; print_int right_var; print_string " \n";*)
						 if right_var >= p2'.gvar then
							begin
		            _update p [1] [] left_var (right_var +Array.length p1'.vars + p1'.cutpoints);
								_update p [1] [] (right_var +Array.length p1'.vars + p1'.cutpoints) left_var
							end
		         else
			          _update p [1] [] left_var right_var;
								_update p [1] [] right_var left_var;
		      done;		   
					(*print_string "\n-----------P1-----P2------\n";
					print_cons p1';
					print_cons p2';
					print_string "-----------P-----------\n";
					print_merge_cons p p1' p2'; *)					
		      ret := p::!ret;
	     done;
		  end;
		end;	
		if List.length(!ret) == 0 then
			let newp = _extend p1 p2 in
			[newp]
		else
			!ret		*)
			[_extend p1 p2]
end

		(*let p = _extend p1 p2 in	
		if i2 >= p2.gvar then
		  [_update p [1] [] i1 (i2+Array.length p1.vars + p1.cutpoints)],true	
		else
			[_update p [1] [] i1 i2],true*)
let remove_2_from b = begin
  let newb = ref [] in
  for i = 0 to List.length(b)-1 do
    let t = List.nth b i in
    if List.nth t 2 <> 2 then
      newb := t::!newb
    else
      newb := [[List.nth t 0] @ [List.nth t 1] @ [0]] @ [[List.nth t 0] @ [List.nth t 1] @ [1]] @ !newb;
  done;
  !newb
end
let join_cons p1 p2 = begin
  (*update_scope p1;
     update_scope p2;*)
  
  let p = clone p2 in
  let terminate = ref 0 in
  if p1.bound == p2.bound && p1.cutpoints == p2.cutpoints && (p1.threads.(0).pc == p2.threads.(0).pc)  then begin
  for i = 0 to p1.bound do
    for j = 0 to p1.bound do
      if !terminate == 0 then begin
        if ((Info.is_reach p1.heap.(i).(j) == 0 && Info.is_reach p2.heap.(i).(j) == 0))
          (*&& p1.data.(i).(0) == p2.data.(i).(0) *) && p1.scope.(i).(0) == p2.scope.(i).(0) then begin 
          let a_label_1 = Info.get_a_label p1.heap.(i).(j) in
          let a_label_2 = Info.get_a_label p2.heap.(i).(j) in
          let b_label_1 = Info.get_b_label p1.heap.(i).(j) in
          let b_label_2 = Info.get_b_label p2.heap.(i).(j) in
          if (List.nth a_label_1 1) <> (List.nth a_label_2 1) then
              terminate := 1
          else
          let join_a_label = if ((List.nth a_label_1 2) + (List.nth a_label_2 2)) == 1 then
          [(List.nth a_label_1 0)] @ [(List.nth a_label_1 1)] @ [2] else
            if (List.nth a_label_1 2) == 2 then a_label_1 else if (List.nth a_label_2 2) == 2 then a_label_2 else a_label_1 in
          
          let join_b_label = remove_duplicates (b_label_1 @ b_label_2)  in
          let join_label = Info.update_label p2.heap.(i).(j) join_a_label join_b_label in
          p.heap.(i).(j) <- join_label;
          if ((List.nth a_label_1 2) + (List.nth a_label_2 2)) == 1 then
            p.data.(j).(0) <- 2 ;
        end
          else
            if ((Info.is_reach p1.heap.(i).(j) == 0 && Info.is_reach p2.heap.(i).(j) <> 0))
            then
              terminate := 1
                else
                  if ((Info.is_reach p1.heap.(i).(j) <> 0 && Info.is_reach p2.heap.(i).(j) == 0))
            then
              terminate := 1
                else
            if (Info.is_equal p1.heap.(i).(j) == 0 && Info.is_equal p2.heap.(i).(j) <> 0) || (Info.is_equal p1.heap.(i).(j) <> 0 && Info.is_equal p2.heap.(i).(j) == 0) then
           terminate := 1;
      end;   
    done;
  done;
  end
  else
    terminate := 1;
    (* if !terminate == 0 then begin
    strengthen p; 
       end;*)
  (p, !terminate)
end 

let next_var p k eq_list = begin
  let ret = ref (p.bound+1) in
	let flag = ref 0 in
  for i = 0 to p.bound do
		if !flag == 0 then begin
	   if Info.is_reach p.heap.(k).(i) == 0 then
       ret := i
		 else
		   if Info.is_equal p.heap.(k).(i) == 0 && i <> k && List.mem (i,k) !eq_list == false then
				begin
				ret := i;
				eq_list := (k,i)::!eq_list;
				flag := 1;
				end; 
		 end;
  done;		
	
  !ret
end
	
let same_skeleton p1 p2 i1 i2 = begin    
      let l = ref [] in
      let ret = ref 1 in
			let eq_list1 = ref [] in
			let eq_list2 = ref [] in
      let rec same_skeleton' p1 p2 i1 i2 = begin
      let r1,r2 =  next_var p1 i1 eq_list1, next_var p2 i2 eq_list2 in
        if r1 == 0 && r2 == 0 then begin l := (i1,i2)::!l; ret := 0 end
      else
        if r1 == 0 && r2 <> 0 || r1 <> 0 && r2 == 0 then ret := 1
        else        
          if i1 <= p1.bound - p1.cutpoints && i2 <= p2.bound - p2.cutpoints && i1 <> i2 then ret := 1 else begin l := (i1,i2)::!l;same_skeleton' p1 p2 r1 r2 end
      end in
      same_skeleton' p1 p2 i1 i2;
      (!l,!ret)
    end   




let join_cons_full p1 p2 = begin
	let pointer_merge x y = begin
		match x,y with
		| 2,2 -> 2
		| 2,4 -> 4
		| 4,2 -> 4
		| 4,4 -> 4
		| 1,4 -> 4
		| 4,1 -> 4
		| 1,2 -> 4
		| 2,1 -> 4
		| 1,1 -> 1
		| _,_ -> 10
	end in
	let ord_merge x y = begin
		match x,y with
		| 2,2 -> 2
		| 2,3 -> 2
		| 3,2 -> 2
		| 3,3 -> 3
		| _,_ -> 10
	end in
	let data_merge x y = begin
		match x,y with
		| 1,0 -> 2
		| 0,1 -> 2
		| 1,1 -> 1
		| 0,0 -> 0
		| 0,2 -> 2
		| 2,0 -> 2
		| 2,2 -> 2
		| 2,1 -> 2
		| 1,2 -> 2
		| _,_ ->5

	end in
	let newbound = p1.bound+p2.cutpoints in
	let newheap = Array.make_matrix (newbound+1) (newbound+1) Info.none in
	let scope =   Array.make_matrix (newbound+1) 1 0 in
	let data =    Array.make_matrix (newbound+1) 1 0 in
  for i = 0 to newbound do
	newheap.(i).(i) <- Info.equal;
	done;
	let p = clone p1 in
	let p3 = clone p1 in
  let ret = ref 0 in
  if (p1.threads.(0).pc == p2.threads.(0).pc)  then begin
  let mapping_pair, sk = same_skeleton p1 p2 3 3 in
	
	let root = ref 3 in
	if sk == 0 then begin
	for n = List.length(mapping_pair) - 1 downto 1 do
	let i1,i2 = List.nth mapping_pair n in
	let r1,r2 = List.nth mapping_pair (n-1) in 	
	let a_label_1 = Info.get_a_label p1.heap.(i1).(r1) in
  let a_label_2 = Info.get_a_label p2.heap.(i2).(r2) in
  let b_label_1 = Info.get_b_label p1.heap.(i1).(r1) in
  let b_label_2 = Info.get_b_label p2.heap.(i2).(r2) in
  if (List.nth a_label_1 1) <> (List.nth a_label_2 1) && (List.nth a_label_1 0) <> 1 && (List.nth a_label_2 0) <> 1 then
         ret := 1
   else	begin															 
          let join_a_label = [pointer_merge (List.nth a_label_1 0) (List.nth a_label_2 0)] @ [ord_merge (List.nth a_label_1 1) (List.nth a_label_2 1)] @ [data_merge (List.nth a_label_1 2) (List.nth a_label_2 2)]	in											                  
          let join_b_label = remove_duplicates (b_label_1 @ b_label_2)  in
					(*If r1 is not cutpoint ,r2 is cutpoints:*)		
					if r1 <= p1.bound-p1.cutpoints && r2 > p2.bound-p2.cutpoints then 
						begin 
							newheap.(!root).(r2 +p1.cutpoints) <- Info.update_label p2.heap.(i2).(r2) join_a_label join_b_label; root := r2+p1.cutpoints; 
							if Info.is_reach p2.heap.(r1).(r2) == 0 then newheap.(r1).(r2 +p1.cutpoints) <- Info.update_star  p2.heap.(r1).(r2) else ret := 1;  
							data.(r2+p1.cutpoints).(0) <- data_merge p1.data.(r1).(0) p2.data.(r2).(0);
					  end
					else	
					   begin 
							newheap.(!root).(r1) <- Info.update_label p1.heap.(i1).(r1) join_a_label join_b_label; root := r1;	data.(r1).(0) <- data_merge p1.data.(r1).(0) p2.data.(r2).(0);
						  if r1 > p1.bound-p1.cutpoints && r2 <= p2.bound-p2.cutpoints then if Info.is_reach p1.heap.(r2).(r1) == 0 then newheap.(r2).(r1) <- Info.update_star  p1.heap.(r2).(r1) else ret := 1;
						 end;
		end;
	done;  
	end
	else ret := 1;
	if !ret == 0 then begin
		p3.heap <- newheap;
		p3.cutpoints <- p1.cutpoints + p2.cutpoints;
		p3.bound <- newbound;
		p3.data <- data;
		p3.scope <- scope;
		(*Local joining*) 
		let eq_list1 = ref [] in
	  let eq_list2 = ref [] in
		for i = 0 to p1.bound - p1.cutpoints do
			if p1.scope.(i).(0) == 1 && p2.data.(i).(0) == 1 then 
				begin
				data.(i).(0) <- p1.data.(i).(0);	
				scope.(i).(0) <- p1.scope.(i).(0);	
				let r1,r2 =  next_var p1 i eq_list1, next_var p2 i eq_list2 in
				let a_label_1 = Info.get_a_label p1.heap.(i).(r1) in
        let a_label_2 = Info.get_a_label p2.heap.(i).(r2) in
        let b_label_1 = Info.get_b_label p1.heap.(i).(r1) in
        let b_label_2 = Info.get_b_label p2.heap.(i).(r2) in
				let join_a_label = [pointer_merge (List.nth a_label_1 0) (List.nth a_label_2 0)] @ [ord_merge (List.nth a_label_1 1) (List.nth a_label_2 1)] @ [data_merge (List.nth a_label_1 2) (List.nth a_label_2 2)]	in											                  
        let join_b_label = remove_duplicates (b_label_1 @ b_label_2)  in
				if r1 == r2 || (List.mem (r1,r2) mapping_pair) == true then 
					begin
						if List.mem (r1,r2) mapping_pair == true then
							if r1 <= p1.bound-p1.cutpoints && r2 > p2.bound-p2.cutpoints then 
							    p3.heap.(i).(r2 +p1.cutpoints) <- Info.update_label p2.heap.(i).(r2) join_a_label join_b_label 							    
					    else	
					      p3.heap.(i).(r1) <- Info.update_label p1.heap.(i).(r1) join_a_label join_b_label
						else
							p3.heap.(i).(r1) <- Info.update_label p1.heap.(i).(r1) join_a_label join_b_label;
					end
					else
						ret := 1; 
				end;
		done;
		if !ret == 0 then
	   begin print_string "p1 and p2"; print_int newbound; print_cons p1; print_cons p2; print_string "ket qua nay"; print_cons p3; end;
		end;		
	end
	else
		ret := 1;		
    (p, !ret)
end 
(*
let join_cons_local p1 p2 = begin
	let p,ret = join_cons_full p1 p2 in
	if ret == 0 then begin
	for i = 0 to p1.bound - p1.cutpoints do
	
	done;
	end;
end
*)
let reach_one p i1 i2 = begin
  let p' = clone p in
  let a_label = Info.get_a_label p.heap.(i1).(i2) in
  let newlabel = (Info.update_label p.heap.(i1).(i2) a_label []) in
  p'.heap.(i1).(i2) <- newlabel;
  p'
end 
  let is_reach p i1 i2 = begin
    Info.is_reach p.heap.(i1).(i2)
end 
  let mark p i1 m = begin
  let p' = clone p in
  p'.data.(i1).(0) <- m;
	for j = 0 to p'.bound do
      if (Info.is_reach p'.heap.(j).(i1)) == 0 then
        p'.heap.(j).(i1) <- Info.update_data_a_label p'.heap.(j).(i1) m;
    done;  
  p'
end 
let is_full p = begin
  update_scope p;
  let ret = ref 0 in
  for i = 0 to p.bound do
    for j = 0 to p.bound do
      if (Info.is_reach_one p.heap.(i).(j)) == 0 && j <> 0 && p.scope.(i).(0) == 0 then
        ret := 1
    done    
  done;
  !ret
end 
  let count_edges p = begin
  let ret = ref 0 in
  for i = 0 to p.bound do
    if p.scope.(i).(0) == 0 then ret := !ret + 1;
  done;
  !ret
end
    let is_pattern_1 p = begin
      if is_full p == 0 && count_edges p == 8 then
        0
      else
        1
    end
      
    let is_pattern p1 p2 i1 i2 = begin    
      let l = ref [] in
      let ret = ref 1 in
      let rec is_pattern' p1 p2 i1 i2 = begin
      let r1,r2 =  List.nth (r p1 i1) 0, List.nth (r p2 i2) 0 in
        if r1 == 0 && r2 == 0 then begin l := (i1,i2)::!l; ret := 0 end
      else
        if r1 == 0 && r2 <> 0 || r1 <> 0 && r2 == 0 then ret := 1
        else
        if Info.compare10 p1.heap.(i1).(r1) p2.heap.(i2).(r2) == 0 && Info.compare10 p2.heap.(i2).(r2) p1.heap.(i1).(r1) == 0 then
         begin 
           l := (i1,i2)::!l; ret := 0;is_pattern' p1 p2 r1 r2
         end
        else
          ret := 1
      end in
      is_pattern' p1 p2 i1 i2;
      (!l,!ret)
    end   
    let column_copy candidate_cons library_cons mapping_list1 mapping_list2 p1 l1 = begin
      let lib_index k mapping_list = begin
        let ret_index = ref 0 in
      for i = 0 to List.length(mapping_list)-1 do
        let candidate_index = fst (List.nth mapping_list i) in
        if k == candidate_index then
          ret_index := snd (List.nth mapping_list i); 
      done;
        !ret_index
      end in
      let bound1 = p1.bound in
      for i = 3 to candidate_cons.bound do
        for j = 0 to candidate_cons.bound do
          if i <= bound1 && j <= bound1 then begin
            if candidate_cons.scope.(i).(0) == 0 && candidate_cons.scope.(j).(0) == 0 && j <> 1 && j <> 2 then
              candidate_cons.heap.(i).(j) <- library_cons.heap.(lib_index i mapping_list1).(lib_index j mapping_list1);
          end;
          if i <= bound1 && j > bound1 then begin
            if candidate_cons.scope.(i).(0) == 0 && candidate_cons.scope.(j).(0) == 0 then
              candidate_cons.heap.(i).(j) <- library_cons.heap.(lib_index i mapping_list1).((lib_index (j-(Array.length p1.vars + p1.cutpoints)) mapping_list2)+Array.length l1.vars + l1.cutpoints);
          end;
          if i > bound1 && j <= bound1 then begin
            if candidate_cons.scope.(i).(0) == 0 && candidate_cons.scope.(j).(0) == 0 && j <> 1 && j <> 2 then
               candidate_cons.heap.(i).(j) <- library_cons.heap.((lib_index (i-(Array.length p1.vars + p1.cutpoints)) mapping_list2)+Array.length l1.vars + l1.cutpoints).(lib_index j mapping_list1);
          end;
          if i > bound1 && j > bound1 then begin
             if candidate_cons.scope.(i).(0) == 0 && candidate_cons.scope.(j).(0) == 0 then
               candidate_cons.heap.(i).(j) <- library_cons.heap.((lib_index (i-(Array.length p1.vars + p1.cutpoints)) mapping_list2)+Array.length l1.vars + l1.cutpoints).((lib_index (j-(Array.length p1.vars + p1.cutpoints)) mapping_list2)+Array.length l1.vars + l1.cutpoints);       
          end;
        done;
      done;
    end
      exception BreakLoop of int
      let is_pair_pattern p1 p2 l = begin
        let ret_list = ref [] in
        let list1,result,return_list,is_pattern_list_1,is_pattern_list_2 = ref p1,ref false,ref [],ref [],ref [] in
      try
      for i = 0 to Array.length(l)-1 do
        let l1,l2,res,ret = l.(i) in
        let (is_pattern_list1, is_pattern_ret1) = is_pattern p1 l1 3 3 in
        let (is_pattern_list2, is_pattern_ret2) = is_pattern p2 l2 3 3 in
        if is_pattern_ret1 == 0 && is_pattern_ret2 == 0  then 
            begin          
            list1 := l1;
            result := res;
            return_list := ret;
            is_pattern_list_1 := is_pattern_list1;
            is_pattern_list_2 := is_pattern_list2;
            raise (BreakLoop 1);
           end;
      done;
        raise (BreakLoop 2);
      with (BreakLoop 1) ->  if !result==true then
        begin 
          (*Copy cons to ret cons list*)
          for i = 0 to List.length(!return_list)-1 do
            let oldcons = List.nth !return_list i in
            let newcons = _extend p1 p2 in
            (*Copy for p1,p2 part*)
            column_copy newcons oldcons !is_pattern_list_1 !is_pattern_list_2 p1 !list1;    
            ret_list := newcons::!ret_list;
          done;
          (ret_list,0)
        end
      else
        (ref [],1) 
        | (BreakLoop 2) -> (ref [],1) 
      end
        
        
        
  let is_mark_full p = begin
  let ret = ref 0 in
    for i = 5 to p.bound do
      if p.data.(i).(0) == 0 && p.scope.(i).(0) == 0 then
        ret := 1
  done;
  !ret
  end  
      let is_unmark_full p = begin
  let ret = ref 0 in
    for i = 5 to p.bound do
      if p.data.(i).(0) > 0 && p.scope.(i).(0) == 0 then
        ret := 1
  done;
  !ret
end 
let add_critical p x = begin
  let ret = ref 1 in
    for j = 0 to p.bound do
      if (Info.is_reach_one p.heap.(x).(j)) ==0 && j <> 0 && p.scope.(x).(0) == 0 then
        ret := 0
    done;    
  !ret
  end  
let  is_reach_more p i1 i2 = begin
  if Info.is_reach_more p.heap.(i1).(i2) == 0 then
      0
    else
      1
end 
let oktointersect p = begin

  if p.bound == 8  && Info.is_equal p.heap.(5).(6) <> 0 && Info.is_equal p.heap.(7).(4) <> 0 then 0 else 1
end
(*Global intersection of two configuration which have same pc*)
let notoktodo p1 p2 = begin
 ( (p1.threads.(0).pc <> 1020 || p2.threads.(0).pc <> 20) 
  && (p1.threads.(0).pc <> 1019 || p2.threads.(0).pc <> 20)
    &&  (p1.threads.(0).pc <> 20 || p2.threads.(0).pc <> 20))
    || ( (p1.threads.(0).pc == 20 && is_full p2 == 0)
    || (p1.threads.(0).pc == 1019 && is_mark_full p2 == 0)
      || (p1.threads.(0).pc == 1020  && is_unmark_full p2 == 0)
        || (p1.threads.(0).pc == 1013  && is_unmark_full p2 == 0)
           || (p1.threads.(0).pc == 13  && is_unmark_full p2 == 0)
    || oktointersect p1 == 1
      ||((p1.threads.(0).pc == 20 || p1.threads.(0).pc == 1020 || p1.threads.(0).pc == 1013 || p1.threads.(0).pc == 13) && (Info.is_reach p1.heap.(5).(6) <> 0 || p1.data.(5).(0) == 1))
        || ((p1.threads.(0).pc == 1019)  && (Info.is_reach p1.heap.(6).(7) <> 0 || p1.data.(6).(0) == 1))
              (*|| (p1.threads.(0).pc == 1020 || p1.threads.(0).pc == 1019 || p1.threads.(0).pc == 20) && (Info.is_reach p2.heap.(5).(6) <> 0 && p2.threads.(0).pc == 20)*) )
end
(* let check_cond p = begin
   if p.threads.(0).pc == 1020 && p.bound >= 8 && p.data.(6).(0) == 1  && p.scope.(6).(0) == 0 && p.data.(5).(0) == 2  && p.scope.(5).(0) == 0 && Info.is_reach_one p.heap.(5).(6) == 0 then 0 else 1    
end
*)
 let check_cond p = begin
   if Info.is_reach p.heap.(5).(6) == 0 && Info.is_reach p.heap.(6).(4) == 0  then 0 else 1    
end
 let check_cond1 p = begin
   if Info.is_equal p.heap.(5).(6) <> 0 && Info.is_equal p.heap.(7).(4) <> 0  then 0 else 1    
end
let rec intersection f p1 p2 i1 i2 i3 thi = begin
	
	
  if
 	   (p1.threads.(0).pc <> 1020 || p2.threads.(0).pc <> 20) 	
		 &&(p1.threads.(0).pc <> 1019 || p2.threads.(0).pc <> 20)
     &&  (p1.threads.(0).pc <> 20 || p2.threads.(0).pc <> 20) 
		
			   
    	&&   (p1.threads.(0).pc <> 20 || p2.threads.(0).pc <> 1020) 
     &&  (p1.threads.(0).pc <> 1019 || p2.threads.(0).pc <> 1020) 
     &&  (p1.threads.(0).pc <> 1020 || p2.threads.(0).pc <> 1020)
    
     &&  (p1.threads.(0).pc <> 1020 || p2.threads.(0).pc <> 13) 
     &&(p1.threads.(0).pc <> 1019 || p2.threads.(0).pc <> 13) 
     &&  (p1.threads.(0).pc <> 20 || p2.threads.(0).pc <> 13) 
   		
     && (p1.threads.(0).pc <> 1020 || p2.threads.(0).pc <> 1013) 
     &&  (p1.threads.(0).pc <> 1019 || p2.threads.(0).pc <> 1013) 
     &&  (p1.threads.(0).pc <> 20 || p2.threads.(0).pc <> 1013) 
    
	   &&	(p1.threads.(0).pc <> 1020 || p2.threads.(0).pc <> 1019) 
     && (p1.threads.(0).pc <> 20 || p2.threads.(0).pc <> 1019) 
		 	
		
     && (p1.threads.(0).pc <> 1013 || p2.threads.(0).pc <> 20)
     &&  (p1.threads.(0).pc <> 13 || p2.threads.(0).pc <> 20)	
     &&  (p1.threads.(0).pc <> 1013 || p2.threads.(0).pc <> 1020)
     &&  (p1.threads.(0).pc <> 13 || p2.threads.(0).pc <> 1020)
	   &&  (p1.threads.(0).pc <> 1013 || p2.threads.(0).pc <> 13)
     &&  (p1.threads.(0).pc <> 13 || p2.threads.(0).pc <> 13)		
		 &&  (p1.threads.(0).pc <> 1013 || p2.threads.(0).pc <> 1013)
     &&  (p1.threads.(0).pc <> 13 || p2.threads.(0).pc <> 1013) 
     && (p1.threads.(0).pc <> 13 || p2.threads.(0).pc <> 1019)
	   && (p1.threads.(0).pc <> 1013 || p2.threads.(0).pc <> 1019)
		
		 && (p1.threads.(0).pc <> 1019 || p2.threads.(0).pc <> 1019) 
		
 then
		[],false
 else	
	
   if (p1.threads.(0).pc == 20 && is_full p2 == 0) then
     [],false
   else	
     if (p1.threads.(0).pc == 1019 && is_mark_full p2 == 0) then
     [],false
     else	
       if (p1.threads.(0).pc == 1020  && is_unmark_full p2 == 0) then
     [],false
        else	
         if (p1.threads.(0).pc == 1013  && is_unmark_full p2 == 0) then
     [],false
         else
             if (p1.threads.(0).pc == 13  && is_unmark_full p2 == 0) then
     [],false
        else
					        if (p1.threads.(0).pc == 1019)
          && (Info.is_reach p1.heap.(6).(7) <> 0 || p1.data.(6).(0) == 1) then
		[],false
           else 
	 if (p1.threads.(0).pc == 20) 
             && (Info.is_reach p1.heap.(5).(6) <> 0 || p1.data.(5).(0) == 1) then
		[],false
       else	 
	  if (p1.threads.(0).pc == 1020 || p1.threads.(0).pc == 1013 || p1.threads.(0).pc == 13)
             && (Info.is_reach p1.heap.(5).(6) <> 0 || Info.is_reach p1.heap.(6).(7) <> 0 || p1.data.(5).(0) == 1) then
		[],false
       else	 
	 if oktointersect p1 == 1 then
		[],false
       else	
			 if oktointersect p2 == 1 then
		[],false
       else		
   	(*Both of states are leafs and equal*)		
  if is_leaf p1 i1  && is_leaf p2 i2 && (get_leaf p1 i1) == (get_leaf p2 i2) then 
		begin
		let p =	extends_and_update_local_paths p1 p2 in
		let ret = ref [] in
		for i = 0 to List.length(p)-1 do
			let pi = List.nth p i in
			if i2 >= p2.gvar then
		  _direct_update pi [1;3;0] [] i1 (i2+Array.length p1.vars + p1.cutpoints)	
		  else
			_direct_update pi [1;3;0] [] i1 i2;
		ret := pi::!ret;	
			done;
		!ret,true
		end
	else
	(*One of the state is leaf but the other one is not*)
	if (is_leaf p1 i1)  && (is_leaf p2 i2) == false then
	   [],false
	else
	if (is_leaf p2 i2)  && (is_leaf p1 i1) == false then
	   [],false
	else		
		begin		
	(*Otherwise we need to go down and check to see what happen*)
	(*first match*)		
	let p1', res1 = begin
	let mat_1 = match_1 p1 p2 i1 i2 i3 in
	   match mat_1 with
      | _, false -> (*print_string "day nay==========="; print_int i1; print_int i2; print_string "\n";*)[],false (*This path is inconsistent*) 
		| mat, true -> let i1',i2',i3' = fst ((fun (x,y,z)->x) mat),
																			  snd ((fun (x,y,z)->x) mat),
		                                    snd ((fun (x,y,z)->z) mat) in
									 let a_label, b_label =  fst ((fun (x,y,z)->y) mat),
            snd ((fun (x,y,z)->y) mat) in																		
    if (p1.data.(i1').(0) == 1 && p2.data.(i2').(0) == 0) ||  (p1.data.(i1').(0) == 0 && p2.data.(i2').(0) == 1) then 
		[],false
    else							
    if (i1' == 5 && add_critical p2 i2' <> 0 ) && (p1.threads.(0).pc == 20) 
     then 
		 [],false
          else
		  if (i1' == 6 && p2.data.(i2').(0) == 2 ) && (p1.threads.(0).pc == 1019) 
     then 
		 [],false
          else					  
						  
		(*if (i1' == 6  &&i2' <>  5  &&i2' <>   6  &&i2' <>  7 ) && (p1.threads.(0).pc == 1020  ||p1.threads.(0).pc == 1013 || p1.threads.(0).pc == 13) 
     then 
		 [],false
          else
			*)				
			match intersection f p1 p2 i1' i2' i3' 1 with 
                   | _, false -> (*print_int i1; print_int i2;*)[],false (*This path is also inconsistent*)
		               | newp, true  -> let rec update plist =  match plist with
													|  [] -> []
													|  hd::tl -> let newp1 = _update (_update hd a_label b_label (new_index p1 i3 thi) i3') [1;3;0] [] i1' (new_index p1 i2' 2 ) in 
													(_update newp1 [1;3;0] [] (new_index p1 i2' 2) i1')::update tl in
																		(update newp), true
	end in 
	(*second match*)   
    let p2', res2 = begin	
      	let mat_2 = match_2 p1 p2 i1 i2 i3 in
				
	   match mat_2 with
		| _, false ->  [],false (*This path is inconsistent*) 
		| mat, true -> let i1',i2',i3' = fst ((fun (x,y,z)->x) mat),
																			  snd ((fun (x,y,z)->x) mat),
		                                    snd ((fun (x,y,z)->z) mat) in
									 let a_label, b_label =  fst ((fun (x,y,z)->y) mat),
									                         snd ((fun (x,y,z)->y) mat) in
																					
      let b_label_old = Info.get_b_label p2.heap.(i2).(List.nth (r p2 i2) 0) in 
   					 if i1' == 6  && ((p1.threads.(0).pc == 1019)) && List.length(b_label_old) > 1 then
			 [],false
          else
						 let b_label_old = Info.get_b_label p2.heap.(i2).(List.nth (r p2 i2) 0) in 
   					 if i1' == 6  && ((p1.threads.(0).pc == 1013) || (p1.threads.(0).pc == 13) || (p1.threads.(0).pc == 1020))  then
			 [],false
          else
		               match intersection f p1 p2 i1' i2' i3' 1 with 
		               | _, false -> [],false (*This path is also inconsistent*)
		               | newp, true  -> let rec update plist =  match plist with
																													|  [] -> []
																													|  hd::tl -> _update hd a_label b_label (new_index p1 i3 thi) i3'::update tl in 
																						(update newp), true
	end in
	
	(*third match*)
    let p3', res3 = begin
    let mat_3 = match_3 p1 p2 i1 i2 i3 in
	   match mat_3 with
		| _, false ->  [],false (*This path is inconsistent*) 
		| mat, true -> let i1',i2',i3' = fst ((fun (x,y,z)->x) mat),
																			  snd ((fun (x,y,z)->x) mat),
		                                    snd ((fun (x,y,z)->z) mat) in
									 let a_label, b_label =  fst ((fun (x,y,z)->y) mat),
									                         snd ((fun (x,y,z)->y) mat) in
		               match intersection f p1 p2 i1' i2' i3' 2 with 
		               | _, false -> [], false (*This path is also inconsistent*)
		               | newp, true  ->  let rec update plist =  match plist with
																													|  [] -> []
																													|  hd::tl -> _update hd a_label b_label (new_index p1 i3 thi) (new_index p1 i3' 2)::update tl in
																													    
																						(update newp), true
	end in	
    let result = 	match res1, res2, res3 with
	| true,true,true ->  p1'@p2'@p3', true
	| true,false,true ->  p1'@p3', true
	| false,true,false ->  p2', true
	| true,true,false ->   p1'@p2', true
	| false,true,true ->   p2'@p3', true
	| false,false,true -> p3', true
	| false, false,false -> [], false
  | true,false,false -> p1',true in
     result
    (* p1',res1	*)
	end
end





  let test p1 p2 = begin
    (*update p1 and p2 according to your wishes*)
    p1.scope.(7).(0) <- 0;
    p2.scope.(7).(0) <- 0;
    p1.heap.(3).(4) <- Info.none;
    p2.heap.(3).(4) <- Info.none;
    p1.heap.(3).(7) <- Info.reachone 2 2 0;
    p2.heap.(3).(7) <- Info.reachmore 2 2 0 0;
    p1.heap.(7).(4) <- Info.reach2more 2 2 0 0;
    p2.heap.(7).(4) <- Info.reach2more 2 2 0 1;
          print_string "first predicate: "; print_cons p1; 
      print_string "second_predicate "; print_cons p2;
    let interConstraintList, res = intersection 1 p1 p2 3 3 3 1 in    
    print_string "-----------------------HAHA---------------------------\n";
    if res then begin
         print_string "-----------------------MERGE---------------------------\n";
           for k = 0 to (List.length interConstraintList)-1 do														 
             print_cons (List.nth interConstraintList k);
           done;
    end
    else
      print_string "-----------------------NOOOOO MERGE---------------------------\n";
  
 end
  
(* 
 let local_intersect l1 l2 = begin
	let pairs_list = ref [[(0,0)]] in
	 let rec map l1 l2 pl start = begin
		let newstart = List.length(!pl) in
		for k = start to List.length(!pl)-1 do
			let curr = List.nth !pl k in
			let last_pair_in_curr = List.nth curr (List.length(curr)-1) in
  		let i,j = fst last_pair_in_curr, snd last_pair_in_curr in
			if i < List.length l1 - 1 then
			   for j' = j+1 to List.length l2 -1 do
           pl := !pl@[curr@[(i+1,j')]] 
		     done;
		done;	
		if newstart < List.length(!pl) then
			map l1 l2 pl newstart	
	 end in
	map l1 l2 pairs_list 0;
		for i = 0 to List.length(!pairs_list)-1 do
		let current = List.nth !pairs_list i in
		print_string "\n";
		 for j = 0 to List.length(current)-1 do
			let pair = List.nth current j in
			  print_int (List.nth l1 (fst pair)); print_int (List.nth l2 (snd pair)); print_string "  ";
		 done;
	done;
end
*)
    


(* =================================================================================== *)

let join ~org ~extra : bool = begin
  assert( Observer.same_state org.observer extra.observer );
  assert( org.gvar = extra.gvar );
  assert( org.colors = extra.colors );
  assert( org.nth = extra.nth );
  let changed = ref false in
  !changed
end

    
(* =================================================================================== *)

let create_queue (head:Label.t) (tail:Label.t) colors bits locks = begin
  assert( 3 = Label.unpack head && 4 = Label.unpack tail );
  let c = create ~example:Q 1 [|head;tail|] colors bits locks in
  let iNull, iHead, iTail = index c (-1) Label.nil, index c (-1) head, index c (-1) tail in
  List.iter (fun (i,j) -> c.heap.(i).(j) <- Info.none; c.heap.(j).(i) <- Info.none;) [(iHead,iNull);(iTail,iNull);(iHead,iTail)];
  _add c iHead iNull Info.reach;
  _add c iTail iNull Info.reach;
  c.heap.(iHead).(iTail) <-  Info.equal;
  c.heap.(iTail).(iHead) <-  Info.equal;
  [c]
end

let create_set (head:Label.t) (tail:Label.t) colors bits locks = begin
  assert( 3 = Label.unpack head && 4 = Label.unpack tail );
  let c = create ~example:Q 1 [|head;tail|] colors bits locks in
  let iNull, iHead, iTail = index c (-1) Label.nil, index c (-1) head, index c (-1) tail in
  List.iter (fun (i,j) -> c.heap.(i).(j) <- Info.none; c.heap.(j).(i) <- Info.none;) [(iHead,iNull);(iTail,iNull);(iHead,iTail)];
  c.heap.(iHead).(iTail) <-  Info.reach 2;
  c.heap.(iTail).(iHead) <-  Info.none;
	c.heap.(iTail).(0) <-  Info.reach 2;
  [c]
end

let create_stack (top:Label.t) colors bits locks = begin
  assert( 3 = Label.unpack top );
  let c = create ~example:Rest 2 [|top|] colors bits locks in
  let res = assign top Label.nil c (-1) in 
  res
end

let create_priority_queue_buckets (heads:Label.t array) (tails:Label.t array) colors locks = begin
  let c = create ~example:Q 2 (Array.append heads tails) colors 0 locks in
  let size = Array.length heads - 1 in
  assert( size = Array.length tails - 1 );
  let iNull = index c (-1) Label.nil in
  for i=0 to size do
    let iHead, iTail = index c (-1) heads.(i), index c (-1) tails.(i) in
    List.iter (fun (i,j) -> c.heap.(i).(j) <- Info.none; c.heap.(j).(i) <- Info.none;) [(iHead,iNull);(iTail,iNull);(iHead,iTail)];
    _add c iHead iNull Info.reach;
    _add c iTail iNull Info.reach;
    c.heap.(iHead).(iTail) <-  Info.equal;
    c.heap.(iTail).(iHead) <-  Info.equal;
  done;
  [c]
end

let create_priority_queue_listbased (head:Label.t) (tailhigh:Label.t) (taillow:Label.t) colors locks = begin
  let c = create ~example:Q 2 [|head;tailhigh;taillow|] colors 0 locks in
  let iNull, iHead, iTailHigh = index c (-1) Label.nil, index c (-1) head, index c (-1) tailhigh in
  List.iter (fun (i,j) -> c.heap.(i).(j) <- Info.none; c.heap.(j).(i) <- Info.none;) [(iHead,iNull);(iTailHigh,iNull);(iHead,iTailHigh)];
  _add c iHead iNull Info.reach;
  _add c iTailHigh iNull Info.reach;
  c.heap.(iHead).(iTailHigh) <- Info.equal;
  c.heap.(iTailHigh).(iHead) <- Info.equal;
  let res = assign taillow tailhigh c (-1) in
  res
end

let _global_intersection p1 p2 = begin
	let bound = p1.bound + (Array.length p2.vars) in
	p1  
end

