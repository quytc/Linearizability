(* open Printf *)

module C = Constraint
module R = Rule

module type E =
    sig
      val name: string
      val initial_predicates: C.t list
      val predicate_transformers:  R.t list
(*       val print: string -> R.t list -> unit *)
    end

(* module LockFreeQueueSetNaive : E = struct *)

(*   let name = "LockFreeQueueSetNaive" *)

(*   let qHead = Label.global ("H") *)
(*   let null = Label.nil *)
(*   let node = Label.local ("n") *)
(*   let v = Label.local ("v") *)
(*   let pred = Label.local ("pred") *)
(*   let curr = Label.local ("curr") *)
(*   let pred' = Label.local ("pred'") *)
(*   let curr' = Label.local ("curr'") *)
(*   let succ' = Label.local ("succ'") *)
(*   let res' = Label.local ("res'") *)
(*   let v' = Label.local ("v'") *)
(*   let pred'' = Label.local ("pred''") *)
(*   let curr'' = Label.local ("curr''") *)
(*   let succ'' = Label.local ("succ''") *)
(*   let res'' = Label.local ("res''") *)
(*   let v'' = Label.local ("v''") *)

(*   let initial_predicates ob = C.create_empty_queue [qHead] *)

(*   let predicate_transformers ob = *)
(*     begin match Observer.get_all_data ob with *)
(*     | [] -> failwith ("Eh? Not manipulating data?") *)
(*     | all_data -> *)
(* 	List.fold_left (fun acc data -> *)
(*           (\* enqueue *\) *)
(* 	  (new R.atomic 0 1000 [(new R.init_thread 0 (-1) [node;pred;curr;] [(v,data)]);(new R.record_insert (-1) 1000 v);]):: *)
(* 	  (\* dequeue *\) *)
(* 	  (new R.init_thread 0 2000 [pred';curr';succ'] [(res',Data.top);(v',data)]):: *)
(* 	  (\* contains *\) *)
(* 	  (new R.init_thread 0 3000 [pred'';curr'';succ''] [(res'',Data.top);(v'',data)]):: *)
(* 	  acc) [] all_data *)
(*     end *)
(*     @ *)
(*     [ *)
(*     (\* ============================ enqueue =============================== *\) *)
(*     (\* search *\) *)
(*     (new R.assign 1000 1001 pred qHead); *)

(*     (new R.assign_dot_next 1001 1002 curr pred); *)
(*     (new R.equality 1002 1 curr null); (\* not found, so do insertion *\) *)

(*     (new R.inequality 1002 1003 curr null); *)
(*     (new R.data_equality 1003 5 1004 curr v); (\* gotcha *\) *)
(*     (new R.data_inequality 1003 1004 5 curr v); (\* goto next item *\) *)
 
(*     (new R.assign 1004 1001 pred curr); *)
 
(*     (\* insert item *\) *)
(*     (new R.new_cell 1 2 node); *)
(*     (new R.data_assign_var 2 3 node v); *)
(*     (new R.dot_next_assign 3 4 node null); *)
(*     (new R.atomic 4 5 [(new R.cas_next_success 4 (-1) pred null node);(new R.validate_insert (-1) 5 "insert" ob);]); *)
(*     (new R.cas_next_fail 4 1000 pred null node); *)
    
(*     (new R.kill_thread 5 0); *)
    
(*     (\* ============================ dequeue =============================== *\) *)
(*     (\* search *\) *)
(*     (new R.assign 2000 2001 pred' qHead); *)

(*     (new R.assign_dot_next 2001 2002 curr' pred'); *)
(*     (new R.equality 2002 103 curr' null); (\* not found, so exit *\) *)

(*     (new R.inequality 2002 2003 curr' null); *)
(*     (new R.data_equality 2003 101 2004 curr' v'); (\* gotcha, do deletion *\) *)
(*     (new R.data_inequality 2003 2004 101 curr' v'); (\* goto next item *\) *)
 
(*     (new R.assign 2004 2001 pred' curr'); *)
    
(*     (\* remove the item *\) *)
(*     (new R.assign_dot_next 101 102 succ' curr'); (\* curr is not null *\) *)
(*     (new R.atomic 102 103 [(new R.cas_next_success 102 (-2) pred' curr' succ');(new R.var_assign_data (-2) (-1) res' curr');(new R.validate_delete (-1) 103 "delete" res' ob)]); *)
(*     (new R.cas_next_fail 102 2000 pred' curr' succ'); *)

(*     (new R.kill_thread 103 0); *)

(*     (\* ============================ contains =============================== *\) *)
(*     (\* search *\) *)
(*     (new R.assign 3000 3001 pred'' qHead); *)

(*     (new R.assign_dot_next 3001 3002 curr'' pred''); *)
(*     (new R.equality 3002 303 curr'' null); (\* not found, so exit *\) *)

(*     (new R.inequality 3002 3003 curr'' null); *)
(*     (new R.data_equality 3003 301 3004 curr'' v''); (\* gotcha, return that you found it *\) *)
(*     (new R.data_inequality 3003 3004 301 curr'' v''); (\* goto next item *\) *)
 
(*     (new R.assign 3004 3001 pred'' curr''); *)

(*     (\* return true *\) *)
(*     (new R.atomic 301 303 [(new R.var_assign_data 301 (-1) res'' curr'');(new R.validate_delete (-1) 303 "contains" res'' ob)]); *)

(*     (new R.kill_thread 303 0); *)

(*   ] *)

(*   let grouping = [ *)
(*     ("enqueue","pink","Enqueue",[1000;1001;1002;1003;1004;1;2;3;4;5]); *)
(*     ("dequeue","yellow","Dequeue",[2000;2001;2002;2003;2004;101;102;103;]); *)
(*     ("contains","lightblue","Contains",[3000;3001;3002;3003;3004;301;303;]); *)
(*   ] *)
(* end *)

(* module LockFreeQueueSet : E = struct *)

(*   let name = "LockFreeQueueSet" *)

(*   let qHead = Label.global ("H") *)
(*   let null = Label.nil *)
(*   let node = Label.local ("n") *)
(*   let pred = Label.local ("pred") *)
(*   let curr = Label.local ("curr") *)
(*   let succ = Label.local ("succ") *)
(*   let v = Label.local ("v") *)
(*   let pred' = Label.local ("pred'") *)
(*   let curr' = Label.local ("curr'") *)
(*   let succ' = Label.local ("succ'") *)
(*   let res' = Label.local ("res'") *)
(*   let v' = Label.local ("v'") *)
(*   let pred'' = Label.local ("pred''") *)
(*   let curr'' = Label.local ("curr''") *)
(*   let succ'' = Label.local ("succ''") *)
(*   let res'' = Label.local ("res''") *)
(*   let v'' = Label.local ("v''") *)

(*   let initial_predicates ob = C.create_empty_queue 0 0 [qHead] [] *)

(*   let predicate_transformers ob = *)
(*     begin match Observer.get_all_data ob with *)
(*     | [] -> failwith ("Eh? Not manipulating data?") *)
(*     | all_data -> *)
(* 	List.fold_left (fun acc data -> *)
(*           (\* enqueue *\) *)
(* 	  (new R.atomic 0 1000 [(new R.init_thread 0 (-1) [node;pred;curr;succ;] [(v,data)]);(new R.record_insert (-1) 1000 v);]):: *)
(* 	  (\* dequeue *\) *)
(* 	  (new R.init_thread 0 2000 [pred';curr';succ';] [(res',Data.top);(v',data)]):: *)
(* 	  (\* contains *\) *)
(* 	  (new R.init_thread 0 3000 [pred'';curr'';succ''] [(res'',Data.top);(v'',data)]):: *)
(* 	  acc) [] all_data *)
(*     end *)
(*     @ *)
(*     [ *)
(*     (\* ============================ enqueue =============================== *\) *)
(*     (\* search *\) *)
(*     (new R.assign 1000 1001 pred qHead); *)
    
(*     (new R.assign_dot_next 1001 1002 curr pred); *)

(*     (new R.inequality 1002 1003 curr null); *)
(*     (new R.equality 1002 11 curr null); (\* 11 = insertion *\) *)

(*     (new R.atomic 1003 1004 [(new R.assign_dot_next 1003 (-1) succ curr);(new R.read_mark (-1) 1004 curr);]); *)
    
(*     (new R.mark_condition 1004 1005 1006 succ); *)
       
(*     (new R.cas_next_success 1005 1001 pred curr succ); (\* go to next item *\) *)
(*     (new R.cas_next_fail 1005 1000 pred curr succ); (\* back to retry *\) *)

(*     (new R.data_equality 1006 15 1001 curr v); (\* gotcha, 15 = exit *\) *)
(*     (new R.data_inequality 1006 1001 15 curr v); (\* goto next item *\) *)

(*     (\* insert item *\) *)
(*     (new R.new_cell 11 12 node); *)
(*     (new R.data_assign_var 12 13 node v); *)
(*     (new R.dot_next_assign 13 14 node null); *)
(*     (new R.atomic 14 15 [(new R.cas_next_success 14 (-1) pred null node);(new R.validate_insert (-1) 15 "insert" ob);]); *)
(*     (new R.cas_next_fail 14 1000 pred null node); *)
    
(*     (new R.kill_thread 15 0); *)
    
(*     (\* ============================ remove =============================== *\) *)
(*     (\* search *\) *)
(*     (new R.assign 2000 2001 pred' qHead); *)
    
(*     (new R.assign_dot_next 2001 2002 curr' pred'); *)

(*     (new R.inequality 2002 2003 curr' null); *)
(*     (new R.equality 2002 23 curr' null); (\* 26 = empty: exit *\) *)

(*     (new R.atomic 2003 2004 [(new R.assign_dot_next 2003 (-1) succ' curr');(new R.read_mark (-1) 2004 curr');]); *)
    
(*     (new R.mark_condition 2004 2005 2006 succ'); *)
       
(*     (new R.cas_next_success 2005 2001 pred' curr' succ'); (\* go to next item *\) *)
(*     (new R.cas_next_fail 2005 2000 pred' curr' succ'); (\* back to retry *\) *)

(*     (new R.data_equality 2006 21 2001 curr' v'); (\* gotcha, 21 = remove me *\) *)
(*     (new R.data_inequality 2006 2001 21 curr' v'); (\* goto next item *\) *)

(*     (\* remove the item *\) *)
(*     (new R.mark_cell 21 22 succ' true); *)

(*     (new R.atomic 22 23 [(new R.cas_next_success 22 (-2) pred' curr' succ');(new R.var_assign_data (-2) (-1) res' curr');(new R.validate_delete (-1) 23 "delete" res' ob)]); *)
(*     (new R.cas_next_fail 22 23 pred' curr' succ'); *)

(*     (new R.kill_thread 23 0); *)

(*     (\* ============================ contains =============================== *\) *)
(*     (\* search *\) *)
(*     (new R.assign 3000 3001 pred'' qHead); *)
    
(*     (new R.assign_dot_next 3001 3002 curr'' pred''); *)

(*     (new R.inequality 3002 3003 curr'' null); *)
(*     (new R.equality 3002 36 curr'' null); (\* 36 = empty: exit *\) *)

(*     (new R.atomic 3003 3004 [(new R.assign_dot_next 3003 (-1) succ'' curr'');(new R.read_mark (-1) 3004 curr'');]); *)
    
(*     (new R.mark_condition 3004 3005 3006 succ''); *)
       
(*     (new R.cas_next_success 3005 3001 pred'' curr'' succ''); (\* go to next item *\) *)
(*     (new R.cas_next_fail 3005 3000 pred'' curr'' succ''); (\* back to retry *\) *)

(*     (new R.data_equality 3006 31 3001 curr'' v''); (\* gotcha, 31 = return true *\) *)
(*     (new R.data_inequality 3006 3001 31 curr'' v''); (\* goto next item *\) *)

(*     (\* return if you found it *\) *)
(*     (new R.atomic 31 36 [(new R.var_assign_data 31 (-1) res'' curr'');(new R.validate_delete (-1) 36 "contains" res'' ob)]); *)

(*     (new R.kill_thread 36 0); *)

(*   ] *)

(*   let grouping = [ *)
(*     ("enqueue","pink","Enqueue",[1000;1001;1002;1003;1004;1005;1006;11;12;13;14;15;]); *)
(*     ("dequeue","yellow","Dequeue",[2000;2001;2002;2003;2004;2005;2006;21;22;23;]); *)
(*     ("contains","lightblue","Contains",[3000;3001;3002;3003;3004;3005;3006;31;36;]); *)
(*   ] *)
(* end *)

(* module CoarsePriorityQueue : E = struct *)

(*   let name = "CoarsePriorityQueue" *)

(*   let qHead = Array.map (fun i -> Label.global (("H"^(string_of_int i)))) [|0;1;|] *)
(*   let qTail = Array.map (fun i -> Label.global (("T"^(string_of_int i)))) [|0;1;|] *)
(*   let null = Label.nil *)
(*   let node = Label.local ("n")  *)
(*   let next' = Label.local ("next'") *)
(*   let res' = Label.local ("res'") *)
(*   let v = Label.local ("v") *)

(*   let initial_predicates ob = C.create_empty_buckets 0 1 qHead qTail [] *)

(*   let predicate_transformers ob = *)
(*     begin match Observer.get_all_data ob with *)
(*     | [] -> failwith ("Eh? Not manipulating data?") *)
(*     | all_data -> *)
(* 	List.fold_left (fun acc data -> *)
(* 	  (\* enqueue high *\) *)
(* 	  (new R.atomic 0 1 [(new R.init_thread 0 (-1) [node] [(v,data)]);(new R.record_insert (-1) 1 v);]):: *)
(* 	  (\* enqueue low *\) *)
(* 	  (new R.atomic 0 11 [(new R.init_thread 0 (-1) [node] [(v,data)]);(new R.record_insert (-1) 11 v);]):: *)
(* 	  acc) [] all_data *)
(*     end *)
(*     @ *)
(*     [ *)
(*     (\* ============================ enqueue =============================== *\) *)
(*     (\* enqueue high *\) *)
(*     (new R.main_lock 1 2 0); *)
(*     (new R.new_cell 2 3 node); *)
(*     (new R.data_assign_var 3 4 node v); *)
(*     (new R.dot_next_assign 4 5 node null); *)
(*     (new R.atomic 5 6 [(new R.dot_next_assign 5 (-1) qTail.(1) node);(new R.validate_insert (-1) 6 "insertHigh" ob); ]); *)
(*     (new R.assign 6 7 qTail.(1) node); *)
(*     (new R.main_unlock 7 1000 0); *)

(*     (\* enqueue low *\) *)
(*     (new R.main_lock 11 12 0); *)
(*     (new R.new_cell 12 13 node); *)
(*     (new R.data_assign_var 13 14 node v); *)
(*     (new R.dot_next_assign 14 15 node null); *)
(*     (new R.atomic 15 16 [(new R.dot_next_assign 15 (-1) qTail.(0) node);(new R.validate_insert (-1) 16 "insertLow" ob); ]); *)
(*     (new R.assign 16 17 qTail.(0) node); *)
(*     (new R.main_unlock 17 1000 0); *)

(*     (\* ============================ dequeue =============================== *\) *)
(*     (new R.init_thread 0 101 [next'] [(res',Data.top)]); *)
(*     (new R.main_lock 101 102 0); *)

(*     (new R.equality 102 103 qHead.(1) qTail.(1)); (\* high empty *\) *)

(*     (new R.atomic 103 104 [(new R.equality 103 (-1) qHead.(0) qTail.(0));(new R.record_empty (-1) 104);]); (\* low empty *\) *)
(*     (new R.atomic 104 1000 [(new R.main_unlock 104 (-1) 0);(new R.validate_empty (-1) 1000 "validateEmpty" ob);]);  *)

(*     (new R.inequality 102 106 qHead.(1) qTail.(1)); (\* high not empty *\) *)
(*     (new R.assign_dot_next 106 107 next' qHead.(1)); *)
(*     (new R.var_assign_data 107 108 res' next'); *)
(*     (new R.atomic 108 109 [(new R.assign 108 (-2) qHead.(1) next');(new R.make_dummy (-2) (-1) qHead.(1));(new R.validate_delete (-1) 109 "delete" res' ob)]); *)
(*     (new R.main_unlock 109 110 0); *)

(*     (new R.inequality 103 206 qHead.(0) qTail.(0)); (\* low not empty *\) *)
(*     (new R.assign_dot_next 206 207 next' qHead.(0)); *)
(*     (new R.var_assign_data 207 208 res' next'); *)
(*     (new R.atomic 208 209 [(new R.assign 208 (-2) qHead.(0) next');(new R.make_dummy (-2) (-1) qHead.(0));(new R.validate_delete (-1) 209 "delete" res' ob)]); *)
(*     (new R.main_unlock 209 1000 0); *)
    
(*     (new R.kill_thread 1000 0); *)

(*   ] *)

(*   let grouping = [ *)
(*     ("enqueueHigh","pink","Enqueue High Priority",[0;1;2;3;4;5;6;7;]); *)
(*     ("enqueueLow","blue","Enqueue Low Priority",[0;11;12;13;14;15;16;17;]); *)
(*     ("dequeue","yellow","Dequeue",[101;102;103;104;110;106;107;108;109;110;206;207;208;209;]); *)
(*   ] *)
(* end *)

(* module BucketLocksPriorityQueue : E = struct *)

(*   let name = "BucketLocksPriorityQueue" *)

(*   let qHead = Array.map (fun i -> Label.global (("H"^(string_of_int i)))) [|0;1;|] *)
(*   let qTail = Array.map (fun i -> Label.global (("T"^(string_of_int i)))) [|0;1;|] *)
(*   let null = Label.nil *)
(*   let node = Label.local ("n")  *)
(*   let next' = Label.local ("next'") *)
(*   let res' = Label.local ("res'") *)
(*   let v = Label.local ("v") *)

(*   let initial_predicates ob = C.create_empty_buckets 0 2 qHead qTail [] *)

(*   let predicate_transformers ob = *)
(*     begin match Observer.get_all_data ob with *)
(*     | [] -> failwith ("Eh? Not manipulating data?") *)
(*     | all_data -> *)
(* 	List.fold_left (fun acc data -> *)
(* 	  (\* enqueue high *\) *)
(* 	  (new R.atomic 0 1 [(new R.init_thread 0 (-1) [node] [(v,data)]);(new R.record_insert (-1) 1 v);]):: *)
(* 	  (\* enqueue low *\) *)
(* 	  (new R.atomic 0 11 [(new R.init_thread 0 (-1) [node] [(v,data)]);(new R.record_insert (-1) 11 v);]):: *)
(* 	  acc) [] all_data *)
(*     end *)
(*     @ *)
(*     [ *)
(*     (\* ============================ enqueue =============================== *\) *)
(*     (\* enqueue high *\) *)
(*     (new R.main_lock 1 2 0); *)
(*     (new R.new_cell 2 3 node); *)
(*     (new R.data_assign_var 3 4 node v); *)
(*     (new R.dot_next_assign 4 5 node null); *)
(*     (new R.atomic 5 6 [(new R.dot_next_assign 5 (-1) qTail.(1) node);(new R.validate_insert (-1) 6 "insertHigh" ob); ]); *)
(*     (new R.assign 6 7 qTail.(1) node); *)
(*     (new R.main_unlock 7 1000 0); *)

(*     (\* enqueue low *\) *)
(*     (new R.main_lock 11 12 1); *)
(*     (new R.new_cell 12 13 node); *)
(*     (new R.data_assign_var 13 14 node v); *)
(*     (new R.dot_next_assign 14 15 node null); *)
(*     (new R.atomic 15 16 [(new R.dot_next_assign 15 (-1) qTail.(0) node);(new R.validate_insert (-1) 16 "insertLow" ob); ]); *)
(*     (new R.assign 16 17 qTail.(0) node); *)
(*     (new R.main_unlock 17 1000 1); *)

(*     (\* ============================ dequeue =============================== *\) *)
(*     (new R.init_thread 0 101 [next'] [(res',Data.top)]); *)
(*     (new R.main_lock 101 102 0); *)

(*     (new R.equality 102 103 qHead.(1) qTail.(1)); (\* high empty *\) *)

(*     (new R.main_lock 103 104 1); *)
(*     (new R.atomic 104 105 [(new R.equality 104 (-1) qHead.(0) qTail.(0));(new R.record_empty (-1) 105);]); (\* low empty *\) *)
(*     (new R.main_unlock 105 106 1); *)
(*     (new R.atomic 106 1000 [(new R.main_unlock 106 (-1) 0);(new R.validate_empty (-1) 1000 "validateEmpty" ob);]);  *)

(*     (new R.inequality 102 107 qHead.(1) qTail.(1)); (\* high not empty *\) *)
(*     (new R.assign_dot_next 107 108 next' qHead.(1)); *)
(*     (new R.var_assign_data 108 109 res' next'); *)
(*     (new R.atomic 109 110 [(new R.assign 109 (-2) qHead.(1) next');(new R.make_dummy (-2) (-1) qHead.(1));(new R.validate_delete (-1) 110 "delete" res' ob)]); *)
(*     (new R.main_unlock 110 111 1); *)
(*     (new R.main_unlock 111 1000 0); *)

(*     (new R.inequality 104 206 qHead.(0) qTail.(0)); (\* low not empty *\) *)
(*     (new R.assign_dot_next 206 207 next' qHead.(0)); *)
(*     (new R.var_assign_data 207 208 res' next'); *)
(*     (new R.atomic 208 209 [(new R.assign 208 (-2) qHead.(0) next');(new R.make_dummy (-2) (-1) qHead.(0));(new R.validate_delete (-1) 209 "delete" res' ob)]); *)
(*     (new R.main_unlock 209 210 1); *)
(*     (new R.main_unlock 210 1000 0); *)

(*     (\* loop *\) *)
(*     (new R.kill_thread 1000 0); *)

(*   ] *)

(*   let grouping = [ *)
(*     ("enqueueHigh","pink","Enqueue High Priority",[0;1;2;3;4;5;6;7;]); *)
(*     ("enqueueLow","blue","Enqueue Low Priority",[0;11;12;13;14;15;16;17;]); *)
(*     ("dequeue","yellow","Dequeue",[101;102;103;104;105;106;107;108;109;110;206;207;208;209;210;211;]); *)
(*   ] *)
(* end *)

(* module LockFreePriorityQueueNaive : E = struct *)

(*   let name = "LockFreePriorityQueueNaive" *)

(*   let qHead = Array.map (fun i -> Label.global (("H"^(string_of_int i)))) [|0;1;|] *)
(*   let qTail = Array.map (fun i -> Label.global (("T"^(string_of_int i)))) [|0;1;|] *)
(*   let null = Label.nil *)
(*   let head, tail, next = Label.local ("h"), Label.local ("t"), Label.local ("next") *)
(*   let node = Label.local ("n") *)
(*   let head', tail', next' = Label.local ("h'"), Label.local ("t'"), Label.local ("next'") *)
(*   let res' = Label.local ("res'") *)
(*   let head'', tail'', next'' = Label.local ("h''"), Label.local ("t''"), Label.local ("next''") *)
(*   let res'' = Label.local ("res''") *)
(*   let v = Label.local ("v") *)

(*   let initial_predicates ob = C.create_empty_buckets qHead qTail *)

(*   let predicate_transformers ob = *)
(*     begin match Observer.get_all_data ob with *)
(*     | [] -> failwith ("Eh? Not manipulating data?") *)
(*     | all_data -> *)
(* 	List.fold_left (fun acc data -> *)
(* 	  (\* enqueue high *\) *)
(* 	  (new R.atomic 0 1 [(new R.init_thread 0 (-1) [tail;next;node] [(v,data)]);(new R.record_insert (-1) 1 v);]):: *)
(* 	  (\* enqueue low *\) *)
(* 	  (new R.atomic 0 101 [(new R.init_thread 0 (-1) [tail;next;node] [(v,data)]);(new R.record_insert (-1) 101 v);]):: *)
(* 	  acc) [] all_data *)
(*     end *)
(*     @ *)
(*     [ *)
(*     (\* ============================ enqueue =============================== *\) *)
(*     (\* enqueue high *\) *)
(*     (new R.new_cell 1 2 node); *)
(*     (new R.data_assign_var 2 3 node v); *)
(*     (new R.dot_next_assign 3 4 node null); *)
(*     (new R.assign 4 5 tail qTail.(1)); *)
(*     (new R.assign_dot_next 5 6 next tail); *)
(*     (new R.equality 6 7 tail qTail.(1)); *)
(*     (new R.equality 7 8 next null);   *)
(*     (new R.atomic 8 10 [(new R.cas_next_success 8 (-810) tail next node);(new R.validate_insert (-810) 10 "insertHigh" ob);]); *)
(*     (new R.cas_success 10 11 qTail.(1) tail node); *)
(*     (new R.cas_fail 10 11 qTail.(1) tail node); *)

(*     (new R.inequality 6 4 tail qTail.(1)); *)
(*     (new R.cas_next_fail 8 4 tail next node); *)
(*     (new R.inequality 7 9 next null); *)
(*     (new R.cas_success 9 4 qTail.(1) tail next); *)
(*     (new R.cas_fail 9 4 qTail.(1) tail next); *)

(*     (\* enqueue low *\) *)
(*     (new R.new_cell 101 102 node); *)
(*     (new R.data_assign_var 102 103 node v); *)
(*     (new R.dot_next_assign 103 104 node null); *)
(*     (new R.assign 104 105 tail qTail.(0)); *)
(*     (new R.assign_dot_next 105 106 next tail); *)
(*     (new R.equality 106 107 tail qTail.(0)); *)
(*     (new R.equality 107 108 next null);   *)
(*     (new R.atomic 108 110 [(new R.cas_next_success 108 (-1) tail next node);(new R.validate_insert (-1) 110 "insertLow" ob);]); *)
(*     (new R.inequality 106 104 tail qTail.(0)); *)
(*     (new R.cas_next_fail 108 104 tail next node); *)
(*     (new R.inequality 107 109 next null); *)
(*     (new R.cas_success 109 104 qTail.(0) tail next); *)
(*     (new R.cas_fail 109 104 qTail.(0) tail next); *)
(*     (new R.cas_success 110 111 qTail.(0) tail node); *)
(*     (new R.cas_fail 110 111 qTail.(0) tail node); *)

(*     (\* ============================ dequeue =============================== *\) *)
(*     (\* dequeue high *\) *)
(*     (new R.init_thread 0 201 [head';tail';next';head'';tail'';next''] [(res'',Data.top);(res',Data.top)]); *)
(*     (new R.assign 201 202 head' qHead.(1)); *)
(*     (new R.assign 202 203 tail' qTail.(1)); *)
(*     (new R.atomic 203 204 [(new R.assign_dot_next 203 (-1) next' head');(new R.record_empty (-1) 204);]); *)
(*     (new R.equality 204 205 head' qHead.(1)); *)
(*     (new R.inequality 204 201 head' qHead.(1)); *)
(*     (new R.equality 205 206 head' tail'); *)
(*     (new R.equality 206 212 next' null); (\* empty so dequeue low *\) *)
(*     (new R.inequality 206 208 next' null); *)
(*     (new R.cas_success 208 201 qTail.(1) tail' next'); *)
(*     (new R.cas_fail 208 201 qTail.(1) tail' next'); *)

(*     (new R.inequality 205 209 head' tail'); *)
(*     (new R.var_assign_data 209 210 res' next'); *)
(*     (new R.atomic 210 211 [(new R.cas_success 210 (-2) qHead.(1) head' next');(new R.make_dummy (-2) (-1) next');(new R.validate_delete (-1) 211 "delete" res' ob)]); *)
(*     (new R.cas_fail 210 201 qHead.(1) head' next'); *)

(*     (\* dequeue low *\) *)
(*     (new R.assign 212 302 head'' qHead.(0)); *)
(*     (new R.assign 302 303 tail'' qTail.(0)); *)
(*     (new R.atomic 303 304 [(new R.assign_dot_next 303 (-1) next'' head'');(new R.record_empty (-1) 304);]); *)
(*     (new R.equality 304 305 head'' qHead.(0)); *)
(*     (new R.inequality 304 212 head'' qHead.(0)); *)
(*     (new R.equality 305 306 head'' tail''); *)
(*     (new R.atomic 306 211 [(new R.equality 306 (-1) next'' null);(new R.validate_empty (-1) 211 "validateEmpty" ob);]); (\* low is empty too *\) *)
(*     (new R.inequality 306 308 next'' null); *)
(*     (new R.cas_success 308 212 qTail.(0) tail'' next''); *)
(*     (new R.cas_fail 308 212 qTail.(0) tail'' next''); *)

(*     (new R.inequality 305 309 head'' tail''); *)
(*     (new R.var_assign_data 309 310 res'' next''); *)
(*     (new R.atomic 310 211 [(new R.cas_success 310 (-2) qHead.(0) head'' next'');(new R.make_dummy (-2) (-1) next'');(new R.validate_delete (-1) 211 "delete" res'' ob)]); *)
(*     (new R.cas_fail 310 212 qHead.(0) head'' next''); *)

(*     (\* loop *\) *)
(*     (new R.kill_thread 11 0);(new R.kill_thread 111 0);(new R.kill_thread 211 0); *)

(*   ] *)

(*   let grouping = [ *)
(*     ("enqueueHigh","pink","Enqueue High",[1;2;3;4;5;6;7;8;9;10;11;]); *)
(*     ("enqueueLow","yellow","Enqueue Low",[101;102;103;104;105;106;107;108;109;110;111;]); *)
(*     ("dequeueHigh","lightblue","Dequeue High",[201;202;203;204;205;206;208;209;210;211;]); *)
(*     ("dequeueLow","green","Dequeue Low",[212;302;303;304;305;306;308;309;310;]); *)
(*   ] *)
(* end *)

(* module LockFreePriorityQueue : E = struct *)

(*   let name = "LockFreePriorityQueueNaive" *)

(*   let qHead = Array.map (fun i -> Label.global (("H"^(string_of_int i)))) [|0;1;|] *)
(*   let qTail = Array.map (fun i -> Label.global (("T"^(string_of_int i)))) [|0;1;|] *)
(*   let null = Label.nil *)
(*   let head, tail, next = Label.local ("h"), Label.local ("t"), Label.local ("next") *)
(*   let node = Label.local ("n") *)
(*   let head', tail', next' = Label.local ("h'"), Label.local ("t'"), Label.local ("next'") *)
(*   let res' = Label.local ("res'") *)
(*   let head'', tail'', next'' = Label.local ("h''"), Label.local ("t''"), Label.local ("next''") *)
(*   let res'' = Label.local ("res''") *)
(*   let v = Label.local ("v") *)

(*   let initial_predicates ob = C.create_empty_buckets qHead qTail *)

(*   let predicate_transformers ob = *)
(*     begin match Observer.get_all_data ob with *)
(*     | [] -> failwith ("Eh? Not manipulating data?") *)
(*     | all_data -> *)
(* 	List.fold_left (fun acc data -> *)
(* 	  (\* enqueue high *\) *)
(* 	  (new R.atomic 0 1 [(new R.init_thread 0 (-1) [tail;next;node] [(v,data)]);(new R.record_insert (-1) 1 v);]):: *)
(* 	  (\* enqueue low *\) *)
(* 	  (new R.atomic 0 101 [(new R.init_thread 0 (-1) [tail;next;node] [(v,data)]);(new R.record_insert (-1) 101 v);]):: *)
(* 	  acc) [] all_data *)
(*     end *)
(*     @ *)
(*     [ *)
(*     (\* ============================ enqueue =============================== *\) *)
(*     (\* enqueue high *\) *)
(*     (new R.new_cell 1 2 node); *)
(*     (new R.data_assign_var 2 3 node v); *)
(*     (new R.dot_next_assign 3 4 node null); *)
(*     (new R.assign 4 5 tail qTail.(1)); *)
(*     (new R.assign_dot_next 5 6 next tail); *)
(*     (new R.equality 6 7 tail qTail.(1)); *)
(*     (new R.equality 7 8 next null);   *)
(*     (new R.atomic 8 10 [(new R.cas_next_success 8 (-810) tail next node);(new R.validate_insert (-810) 10 "insertHigh" ob);]); *)
(*     (new R.cas_success 10 11 qTail.(1) tail node); *)
(*     (new R.cas_fail 10 11 qTail.(1) tail node); *)

(*     (new R.inequality 6 4 tail qTail.(1)); *)
(*     (new R.cas_next_fail 8 4 tail next node); *)
(*     (new R.inequality 7 9 next null); *)
(*     (new R.cas_success 9 4 qTail.(1) tail next); *)
(*     (new R.cas_fail 9 4 qTail.(1) tail next); *)

(*     (\* enqueue low *\) *)
(*     (new R.new_cell 101 102 node); *)
(*     (new R.data_assign_var 102 103 node v); *)
(*     (new R.dot_next_assign 103 104 node null); *)
(*     (new R.assign 104 105 tail qTail.(0)); *)
(*     (new R.assign_dot_next 105 106 next tail); *)
(*     (new R.equality 106 107 tail qTail.(0)); *)
(*     (new R.equality 107 108 next null);   *)
(*     (new R.atomic 108 110 [(new R.cas_next_success 108 (-1) tail next node);(new R.validate_insert (-1) 110 "insertLow" ob);]); *)
(*     (new R.inequality 106 104 tail qTail.(0)); *)
(*     (new R.cas_next_fail 108 104 tail next node); *)
(*     (new R.inequality 107 109 next null); *)
(*     (new R.cas_success 109 104 qTail.(0) tail next); *)
(*     (new R.cas_fail 109 104 qTail.(0) tail next); *)
(*     (new R.cas_success 110 111 qTail.(0) tail node); *)
(*     (new R.cas_fail 110 111 qTail.(0) tail node); *)

(*     (\* ============================ dequeue =============================== *\) *)
(*     (\* dequeue high *\) *)
(*     (new R.init_thread 0 201 [head';tail';next';head'';tail'';next''] [(res'',Data.top);(res',Data.top)]); *)
(*     (new R.assign 201 202 head' qHead.(1)); *)
(*     (new R.assign 202 203 tail' qTail.(1)); *)
(*     (new R.atomic 203 204 [(new R.assign_dot_next 203 (-1) next' head');(new R.record_empty (-1) 204);]); *)
(*     (new R.equality 204 205 head' qHead.(1)); *)
(*     (new R.inequality 204 201 head' qHead.(1)); *)
(*     (new R.equality 205 206 head' tail'); *)
(*     (new R.equality 206 212 next' null); (\* empty so dequeue low *\) *)
(*     (new R.inequality 206 208 next' null); *)
(*     (new R.cas_success 208 201 qTail.(1) tail' next'); *)
(*     (new R.cas_fail 208 201 qTail.(1) tail' next'); *)

(*     (new R.inequality 205 209 head' tail'); *)
(*     (new R.var_assign_data 209 210 res' next'); *)
(*     (new R.atomic 210 211 [(new R.cas_success 210 (-2) qHead.(1) head' next');(new R.make_dummy (-2) (-1) next');(new R.validate_delete (-1) 211 "delete" res' ob)]); *)
(*     (new R.cas_fail 210 201 qHead.(1) head' next'); *)

(*     (\* dequeue low *\) *)
(*     (new R.assign 212 302 head'' qHead.(0)); *)
(*     (new R.assign 302 303 tail'' qTail.(0)); *)
(*     (new R.atomic 303 304 [(new R.assign_dot_next 303 (-1) next'' head'');(new R.record_empty (-1) 304);]); *)
(*     (new R.equality 304 305 head'' qHead.(0)); *)
(*     (new R.inequality 304 212 head'' qHead.(0)); *)
(*     (new R.equality 305 306 head'' tail''); *)
(*     (new R.atomic 306 211 [(new R.equality 306 (-1) next'' null);(new R.validate_empty (-1) 211 "validateEmpty" ob);]); (\* low is empty too *\) *)
(*     (new R.inequality 306 308 next'' null); *)
(*     (new R.cas_success 308 212 qTail.(0) tail'' next''); *)
(*     (new R.cas_fail 308 212 qTail.(0) tail'' next''); *)

(*     (new R.inequality 305 309 head'' tail''); *)
(*     (new R.var_assign_data 309 310 res'' next''); *)
(*     (new R.atomic 310 211 [(new R.cas_success 310 (-2) qHead.(0) head'' next'');(new R.make_dummy (-2) (-1) next'');(new R.validate_delete (-1) 211 "delete" res'' ob)]); *)
(*     (new R.cas_fail 310 201 qHead.(0) head'' next''); (\* retry *\) *)

(*     (\* loop *\) *)
(*     (new R.kill_thread 11 0);(new R.kill_thread 111 0);(new R.kill_thread 211 0); *)

(*   ] *)

(*   let grouping = [ *)
(*     ("enqueueHigh","pink","Enqueue High",[1;2;3;4;5;6;7;8;9;10;11;]); *)
(*     ("enqueueLow","yellow","Enqueue Low",[101;102;103;104;105;106;107;108;109;110;111;]); *)
(*     ("dequeueHigh","lightblue","Dequeue High",[201;202;203;204;205;206;208;209;210;211;]); *)
(*     ("dequeueLow","green","Dequeue Low",[212;302;303;304;305;306;308;309;310;]); *)
(*   ] *)
(* end *)

    
(* module Deque : E = struct *)

(*   let name = "Deque" *)

(*   let qHead = Label.global ("H") *)
(*   let qTail = Label.global ("T") *)
(*   let null = Label.nil *)
(*   let node = Label.local ("n")  *)
(*   let tail = Label.local ("t")  *)
(*   let head = Label.local ("h")  *)
(*   let next = Label.local ("next")  *)
(*   let head' = Label.local ("h'") *)
(*   let tail' = Label.local ("t'") *)
(*   let next' = Label.local ("next'") *)
(*   let res' = Label.local ("res'") *)
(*   let v = Label.local ("v") *)
(*   let pred' = Label.local ("pred'") *)

(*   let initial_predicates ob = C.create_empty_queue [qHead;qTail] *)

(*   let predicate_transformers ob = *)
(*     begin match Observer.get_all_data ob with *)
(*     | [] -> failwith ("Eh? Not manipulating data?") *)
(*     | all_data -> *)
(* 	List.fold_left (fun acc data -> *)
(*           (\* add last *\) *)
(* 	  (new R.atomic 0 1 [(new R.init_thread 0 (-1) [tail;next;node] [(v,data)]);(new R.record_insert (-1) 1 v);]):: *)
(*           (\* add first *\) *)
(* 	  (new R.atomic 0 400 [(new R.init_thread 0 (-1) [head;next;node] [(v,data)]);(new R.record_insert (-1) 400 v);]):: *)
(* 	  acc) [] all_data *)
(*     end *)
(*     @ *)
(*     [ *)
(*     (\* ============================ addLast =============================== *\) *)
(*     (new R.new_cell 1 2 node); *)
(*     (new R.data_assign_var 2 3 node v); *)
(*     (new R.dot_next_assign 3 4 node null); *)
(*     (new R.assign 4 5 tail qTail); *)
(*     (new R.assign_dot_next 5 6 next tail); *)
(*     (new R.equality 6 7 tail qTail); *)
(*     (new R.equality 7 8 next null);   *)
(*     (new R.atomic 8 10 [(new R.cas_next_success 8 (-810) tail next node);(new R.validate_insert (-810) 10 "addLast" ob);]); *)
(*     (new R.inequality 6 4 tail qTail); *)
(*     (new R.cas_next_fail 8 4 tail next node); *)
(*     (new R.inequality 7 9 next null); *)
(*     (new R.cas_success 9 4 qTail tail next); *)
(*     (new R.cas_fail 9 4 qTail tail next); *)
(*     (new R.cas_success 10 11 qTail tail node); *)
(*     (new R.cas_fail 10 11 qTail tail node); *)

(*     (new R.kill_thread 11 0); *)

(*     (\* ============================ removeFirst =============================== *\) *)
(*     (new R.init_thread 0 101 [head';tail';next'] [(res',Data.top)]); *)
(*     (new R.assign 101 102 head' qHead); *)
(*     (new R.assign 102 103 tail' qTail); *)
(*     (new R.atomic 103 104 [(new R.assign_dot_next 103 (-1) next' head');(new R.record_empty (-1) 104);]); *)
(*     (new R.equality 104 105 head' qHead); *)
(*     (new R.inequality 104 101 head' qHead); *)
(*     (new R.equality 105 106 head' tail'); *)
(*     (new R.atomic 106 111 [(new R.equality 106 (-1) next' null);(new R.validate_empty (-1) 111 "validateEmpty" ob);]); *)
(*     (new R.inequality 106 108 next' null); *)
(*     (new R.cas_success 108 101 qTail tail' next'); *)
(*     (new R.cas_fail 108 101 qTail tail' next'); *)

(*     (new R.inequality 105 109 head' tail'); *)
(*     (new R.var_assign_data 109 110 res' next'); *)
(*     (new R.atomic 110 111 [(new R.cas_success 110 (-1) qHead head' next');(new R.validate_delete (-1) 111 "removeFirst" res' ob)]); *)
(*     (new R.cas_fail 110 101 qHead head' next'); *)

(*     (new R.kill_thread 111 0); *)

(*     (\* ============================ addFirst =============================== *\) *)
(*     (new R.assign 400 401 head qHead); *)
(*     (new R.assign_dot_next 401 402 next head); *)

(*     (new R.new_cell 402 403 node); *)
(*     (new R.data_assign_var 403 404 node v); *)
(*     (new R.dot_next_assign 404 405 node next); *)

(*     (new R.atomic 405 406 [(new R.cas_next_success 405 (-1) head next node);(new R.validate_insert (-1) 18 "addFirst" ob);]); *)
(*     (new R.cas_next_fail 405 400 head next node); *)

(*     (new R.kill_thread 406 0); *)

(* (\*     (\\* ============================ removeLast =============================== *\\) *\) *)
(* (\*     (\\* search for the predecessor of the Tail *\\) *\) *)
(* (\*     (new R.init_thread 0 500 [pred';tail';next'] [(res',Data.top)]); *\) *)
(* (\*     (new R.assign 500 501 pred' qHead); *\) *)

(* (\*     (new R.assign_dot_next 4 5 tail' pred'); *\) *)
(* (\*      (\\* empty *\\) *\) *)
(* (\*     (new R.atomic 501 502 [(new R.next_equality 501 (-1) tail' null);(new R.record_empty (-1) 502);]); *\) *)
(* (\*     (new R.atomic 106 111 [(new R.equality 106 (-1) next' null);(new R.validate_empty (-1) 111 "validateEmpty" ob);]); *\) *)
    
(* (\*     (new R.next_inequality 3 4 pred null); (\\* check and move on *\\) *\) *)
(* (\*     (new R.assign_dot_next 4 5 curr pred); *\) *)
(* (\*     (new R.data_equality 5 10 curr v); (\\* gotcha, unlock and exit *\\) *\) *)
(* (\*     (new R.data_inequality 5 6 curr v); (\\* goto next item *\\) *\) *)
(* (\*     (new R.assign 6 3 pred curr); *\) *)

(* (\*     (\\* insert item *\\) *\) *)
(* (\*     (new R.new_cell 1000 7 node); *\) *)
(* (\*     (new R.data_assign_var 7 8 node v); *\) *)
(* (\*     (new R.dot_next_assign 8 9 node null); *\) *)
(* (\*     (new R.atomic 9 10 [(new R.dot_next_assign 9 (-1) pred node);(new R.validate_insert (-1) 10 "insert" ob); ]); *\) *)
(*   ] *)

(*   let grouping = [ *)
(*     ("addLast","pink","add last position",[1;2;3;4;5;6;7;8;9;10;11;]); *)
(*     ("removeFirst","yellow","remove first position",[101;102;103;104;105;106;108;109;110;111;]); *)
(*     ("addFirst","lightblue","add first position",[400;401;402;403;404;405;406;]); *)
(* (\*     ("removeLast","pink","remove last position",[]); *\) *)
(*   ] *)

(* end *)


(* module FineQueueSet : E = struct *)

(*   let name = "FineQueueSet" *)

(*   let qHead = Label.global ("H") *)
(*   let qTail = Label.global ("T") *)
(*   let null = Label.nil *)
(*   let node = Label.local ("n")  *)
(*   let next' = Label.local ("next'") *)
(*   let head' = Label.local ("h") *)
(*   let res' = Label.local ("res'") *)
(*   let v = Label.local ("v") *)
(*   let v' = Label.local ("v'") *)
(*   let pred = Label.local ("pred") *)
(*   let curr =  Label.local ("curr") *)

(*   let initial_predicates ob = C.create_empty_queue 0 0 [qHead;qTail] [] *)

(*   let predicate_transformers ob = *)
(*     begin match Observer.get_all_data ob with *)
(*     | [] -> failwith ("Eh? Not manipulating data?") *)
(*     | all_data -> *)
(* 	List.fold_left (fun acc data -> *)
(* 	  (\* enqueue *\) *)
(* 	  (new R.atomic 0 1000 [(new R.init_thread 0 (-1) [node;pred;curr;] [(v,data)]);(new R.record_insert (-1) 1000 v);]):: *)
(* 	  (\* dequeue *\) *)
(* 	  (new R.init_thread 0 101 [next';head'] [(res',Data.top);(v',data)]):: *)
(* 	  acc) [] all_data *)
(*     end *)
(*     @ *)
(*     [ *)
(*     (\* ============================ enqueue =============================== *\) *)

(*     (\* search *\) *)
(*     (new R.assign 1000 1001 pred qHead); *)
(*     (new R.lock 1001 1002 pred); *)
    
(*     (new R.next_equality 1002 1 pred null); (\* empty, so do insertion *\) *)
(*     (new R.next_inequality 1002 1003 pred null); (\* not empty, check and move on *\) *)
(*     (new R.assign_dot_next 1003 1004 curr pred); *)
(*     (new R.lock 1004 1005 curr); *)
(*     (new R.unlock 1005 1006 pred); *)

(*     (new R.data_equality 1006 1007 curr v); *)
(*     (new R.unlock 1007 10 curr); (\* unlock and do nothing: return false *\) *)

(*     (new R.data_inequality 1006 1008 curr v); (\* goto next item *\) *)
(*     (new R.assign 1008 1001 pred curr); *)

(*     (\* enqueue *\) *)
(*     (new R.new_cell 1 2 node); *)
(*     (new R.data_assign_var 2 3 node v); *)
(*     (new R.dot_next_assign 3 4 node null); *)
(*     (\* tail is already locked *\) *)
(*     (new R.lock 4 6 node); *)
(*     (new R.atomic 6 7 [(new R.dot_next_assign 6 (-1) qTail node);(new R.validate_insert (-1) 7 "insert" ob);]); *)
(*     (new R.unlock 7 8 qTail); *)
(*     (new R.assign 8 9 qTail node); *)
(*     (new R.unlock 9 10 node); *)

(*     (\* ============================ dequeue =============================== *\) *)
(*     (new R.lock 101 102 qHead); *)

(*     (new R.atomic 102 103 [(new R.equality 102 (-1) qHead qTail);(new R.record_empty (-1) 103);]); *)
(*     (new R.atomic 103 112 [(new R.unlock 103 (-1) qHead);(new R.validate_empty (-1) 112 "validateEmpty" ob);]); *)

(*     (new R.equality 102 103 qHead qTail); *)
(*     (new R.unlock 103 112 qHead); *)

(*     (new R.inequality 102 105 qHead qTail); *)
(*     (new R.assign_dot_next 105 106 next' qHead); *)
(*     (new R.lock 106 107 next'); *)
(*     (new R.var_assign_data 107 108 res' next'); *)
(*     (new R.assign 108 109 head' qHead); *)
(*     (new R.atomic 109 110 [(new R.assign 109 (-1) qHead next');(new R.validate_delete (-1) 110 "delete" res' ob)]); *)
(*     (new R.unlock 110 111 head'); *)
(*     (new R.unlock 111 112 next'); *)
    
(*     (new R.kill_thread 10 0);(new R.kill_thread 112 0); *)
(*   ] *)

(*   let grouping = [] *)
(* end *)

(* module FineQueue : E = struct *)

(*   let name = "FineQueue" *)

(*   let qHead = Label.global ("H") *)
(*   let qTail = Label.global ("T") *)
(*   let null = Label.nil *)
(*   let node = Label.local ("n")  *)
(*   let tail = Label.local ("tail")  *)
(*   let next' = Label.local ("next'") *)
(*   let head' = Label.local ("h") *)
(*   let res' = Label.local ("res'") *)
(*   let v = Label.local ("v") *)

(*   let initial_predicates ob = C.create_empty_queue 0 0 [qHead;qTail] [] *)

(*   let predicate_transformers ob = *)
(*     begin match Observer.get_all_data ob with *)
(*     | [] -> failwith ("Eh? Not manipulating data?") *)
(*     | all_data -> *)
(* 	List.fold_left (fun acc data -> *)
(* 	  (new R.atomic 0 1 [(new R.init_thread 0 (-1) [node;tail] [(v,data)]);(new R.record_insert (-1) 1 v);]):: *)
(* 	  acc) [] all_data *)
(*     end *)
(*     @ *)
(*     [ *)
(*     (\* ============================ enqueue =============================== *\) *)
(*     (new R.new_cell 1 2 node); *)
(*     (new R.data_assign_var 2 3 node v); *)
(*     (new R.dot_next_assign 3 4 node null); *)

(*     (new R.lock 4 5 qTail); *)
(*     (new R.lock 5 6 node); *)
(*     (new R.atomic 6 7 [(new R.dot_next_assign 6 (-1) qTail node);(new R.validate_insert (-1) 7 "insert" ob);]); *)
(*     (new R.assign 7 8 tail qTail); *)
(*     (new R.assign 8 9 qTail node); *)
(*     (new R.unlock 9 10 tail); *)
(*     (new R.unlock 10 11 node); *)

(*     (\* ============================ dequeue =============================== *\) *)
(*     (new R.init_thread 0 101 [next';head'] [(res',Data.top)]); *)
(*     (new R.lock 101 102 qHead); *)

(*     (new R.atomic 102 103 [(new R.equality 102 (-1) qHead qTail);(new R.record_empty (-1) 103);]); *)
(*     (new R.atomic 103 112 [(new R.unlock 103 (-1) qHead);(new R.validate_empty (-1) 112 "validateEmpty" ob);]); *)

(*     (new R.inequality 102 105 qHead qTail); *)
(*     (new R.assign_dot_next 105 106 next' qHead); *)
(*     (new R.lock 106 107 next'); *)
(*     (new R.var_assign_data 107 108 res' next'); *)
(*     (new R.assign 108 109 head' qHead); *)
(*     (new R.atomic 109 110 [(new R.assign 109 (-109110) qHead next');(new R.validate_delete (-109110) 110 "delete" res' ob)]); *)
(*     (new R.unlock 110 111 head'); *)
(*     (new R.unlock 111 112 next'); *)
    
(*     (new R.kill_thread 11 0);(new R.kill_thread 112 0); *)
(*   ] *)

(*   let grouping = [ *)
(*     ("enqueue","yellow","Enqueue",[1;2;3;4;5;6;7;8;9;10;11;]); *)
(*     ("dequeue","pink","Dequeue",[101;102;103;105;106;107;108;109;110;111;112;]); *)
(*   ] *)
(* end *)

(* module FineQueueWrong : E = struct *)

(*   let name = "FineQueueWrong" *)

(*   let qHead = Label.global ("H") *)
(*   let qTail = Label.global ("T") *)
(*   let null = Label.nil *)
(*   let node = Label.local ("n")  *)
(*   let next' = Label.local ("next'") *)
(*   let head' = Label.local ("h") *)
(*   let res' = Label.local ("res'") *)
(*   let v = Label.local ("v") *)

(*   let initial_predicates ob = C.create_empty_queue 0 0 [qHead;qTail] [] *)

(*   let predicate_transformers ob = *)
(*     begin match Observer.get_all_data ob with *)
(*     | [] -> failwith ("Eh? Not manipulating data?") *)
(*     | all_data -> *)
(* 	List.fold_left (fun acc data -> *)
(* 	  (new R.atomic 0 1 [(new R.init_thread 0 (-1) [node] [(v,data)]);(new R.record_insert (-1) 1 v);]):: *)
(* 	  acc) [] all_data *)
(*     end *)
(*     @ *)
(*     [ *)
(*     (\* ============================ enqueue =============================== *\) *)
(*     (new R.new_cell 1 2 node); *)
(*     (new R.data_assign_var 2 3 node v); *)
(*     (new R.dot_next_assign 3 4 node null); *)

(*     (new R.lock 4 5 qTail); *)
(*     (new R.lock 5 6 node); *)
(*     (new R.atomic 6 7 [(new R.dot_next_assign 6 (-1) qTail node);(new R.validate_insert (-1) 7 "insert" ob);]); *)
(*     (new R.unlock 7 8 qTail); (\* why is this one not raising a bad behavior? Where the cell is released, another thread could come a insert an item, losing that current one *\) *)
(*     (new R.assign 8 9 qTail node); *)
(*     (new R.unlock 9 10 node); *)

(*     (\* ============================ dequeue =============================== *\) *)
(*     (new R.init_thread 0 101 [next';head'] [(res',Data.top)]); *)
(*     (new R.lock 101 102 qHead); *)

(*     (new R.atomic 102 103 [(new R.equality 102 (-1) qHead qTail);(new R.record_empty (-1) 103);]); *)
(*     (new R.atomic 103 112 [(new R.unlock 103 (-1) qHead);(new R.validate_empty (-1) 112 "validateEmpty" ob);]); *)
    
(*     (new R.inequality 102 105 qHead qTail); *)
(*     (new R.assign_dot_next 105 106 next' qHead); *)
(*     (new R.lock 106 107 next'); *)
(*     (new R.var_assign_data 107 108 res' next'); *)
(*     (new R.assign 108 109 head' qHead); *)
(*     (new R.atomic 109 110 [(new R.assign 109 (-109110) qHead next');(new R.validate_delete (-109110) 110 "delete" res' ob)]); *)
(*     (new R.unlock 110 111 head'); *)
(*     (new R.unlock 111 112 next'); *)
    
(*     (new R.kill_thread 10 0);(new R.kill_thread 112 0); *)
(*   ] *)

(*   let grouping = [] *)
(* end *)
